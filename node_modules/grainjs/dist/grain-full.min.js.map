{"version":3,"sources":["node_modules/browser-pack/_prelude.js","dist/cjs/index.js","dist/cjs/lib/PriorityQueue.js","dist/cjs/lib/_computed_queue.js","dist/cjs/lib/binding.js","dist/cjs/lib/browserGlobals.js","dist/cjs/lib/computed.js","dist/cjs/lib/dispose.js","dist/cjs/lib/dom.js","dist/cjs/lib/domComponent.js","dist/cjs/lib/domComputed.js","dist/cjs/lib/domDispose.js","dist/cjs/lib/domForEach.js","dist/cjs/lib/domImpl.js","dist/cjs/lib/domMethods.js","dist/cjs/lib/domevent.js","dist/cjs/lib/emit.js","dist/cjs/lib/kowrap.js","dist/cjs/lib/obsArray.js","dist/cjs/lib/observable.js","dist/cjs/lib/pureComputed.js","dist/cjs/lib/styled.js","dist/cjs/lib/subscribe.js","dist/cjs/lib/util.js","dist/cjs/lib/widgets/input.js","dist/cjs/lib/widgets/select.js"],"names":["f","exports","module","define","amd","window","global","self","this","grainjs","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","__createBinding","Object","create","m","k","k2","undefined","defineProperty","enumerable","get","__exportStar","prototype","hasOwnProperty","value","PriorityQueue","[object Object]","_isPrior","_items","size","item","items","isPrior","curIdx","parIdx","parItem","pop","result","leftIdx","rightIdx","bestIdx","bundleChanges","compute","_getPriority","DepItem","PriorityQueue_1","callback","optContext","_priority","_enqueued","_creation","_nextCreationNum","_callback","_context","b","depItem","queue","push","isPrioritySmaller","_seen","bundleDepth","recompute","obs","_getDepItem","func","subscribeElem","subscribeBindable","computed_1","domDispose_1","observable_1","subscribe_1","valueObs","koValue","peek","sub","subscribe","val","comp","computed","addListener","BaseObservable","use","elem","autoDisposeElem","_updateGlobals","dest","source","DocumentFragment","Element","Node","document","popGlobals","pushGlobals","G","initial","assign","_globalsStack","globals","Computed","dispose_1","_noWrite","Observable","dependencies","super","_write","_sub","Subscription","_read","bind","owner","args","readCb","setDisposeOwner","writeFunc","dispose","set","MultiHolder","Holder","Disposable","emit_1","_noopOwner","obj","_defaultDisposableOwner","_disposalList","DisposalList","autoDispose","origDefaultOwner","holder","clear","e2","console","error","name","release","onDispose","context","_wipeOutObject","disposalList","callAndDispose","_describe","keys","_owned","_disposalListener","_onOutsideDispose","_unlisten","ret","owned","disposalListener","constructor","LLink","lis","DisposeListener","_insertBefore","_next","callAll","_disposeList","begin","end","isDisposed","_removeNode","dom","_domComponent","_domComputed","_domDispose","_domForEach","_domImpl","_domMethods","domevent","domImpl_1","tagString","svg","frag","update","find","findAll","domDispose","onDisposeElem","attrsElem","attrs","attrElem","attr","boolAttrElem","boolAttr","textElem","text","styleElem","style","propElem","prop","showElem","show","hideElem","hide","clsElem","cls","clsPrefix","dataElem","data","getData","replaceContent","domComputed","domComputedOwned","maybe","maybeOwned","forEach","onElem","on","onMatchElem","onMatch","onKeyElem","onKeyPress","onKeyDown","domComputed_1","fn","buildDom","binding_1","browserGlobals_1","nodeBefore","nodeAfter","content","parentNode","next","nextSibling","removeChild","insertBefore","contentFunc","arg","markerPre","createComment","markerPost","boolValueObs","domDisposeHooks","_disposeNode","_disposeMap","WeakMap","node","disposer","key","delete","disposerFunc","prevDisposer","disposable","disposeNode","disposeRecursive","_walkDom","visitFunc","firstChild","obsArray_1","obsArray","itemCreateFunc","Array","isArray","map","nodes","computedArray","newArr","oldArr","splice","deleted","numAdded","endIndex","start","nextElem","slice","domMethods_1","_createElementHtml","tag","createElement","_createElementSvg","createElementNS","_createFromTagString","createFunc","id","classes","dotPos","indexOf","hashPos","substring","replace","setAttribute","_updateWithArgs","_updateWithArg","_updateWithArgsOrDispose","appendChild","createTextNode","createDocumentFragment","selector","querySelector","querySelectorAll","noTestId","makeTestId","_dataMap","attrsObj","attrName","attrValue","removeAttribute","boolValue","property","display","className","classList","toggle","Boolean","_clsDynamicPrefix","prefix","prevClass","remove","add","attrValueObs","textNode","nodeValue","DomEventListener","eventType","useCapture","addEventListener","event","cb","removeEventListener","DomEventMatchListener","inner","outer","el","parentElement","matches","_findMatch","target","evType","keyHandlers","tabIndex","ev","_elem","plainHandler","handler","stopPropagation","preventDefault","_noop","Listener","Emitter","_prev","last","_changeCB","_changeCBContext","changeCB","hasListeners","emitter","_triggerChangeCB","setupKoDisposal","toKo","KoWrapObs","fromKo","fromKoWrappers","toKoWrappers","koObs","_koObs","_koSub","setListenerChangeCB","_value","setAndTrigger","knockout","grainObs","prevKoObs","newKoObs","observable","koDisposalIsSetup","ko","koDomNodeDisposal","utils","domNodeDisposal","origKoCleanExternalData","cleanExternalData","origGrainDisposeRecursive","newKoCleanExternalData","cleanNode","LiveIndex","makeLiveIndex","ComputedArray","MutableObsArray","ObsArray","arguments","_ownedItems","Set","_setWithArg","oldOwnedItems","newLen","_setWithSplice","unshift","shift","deleteCount","Infinity","newValues","len","Math","min","max","obsArr","_mapper","_syncMap","obsArrayValue","_unsync","_source","_listener","_recordChange","_rebuild","_lastSplice","_applySplice","change","sourceArray","newItems","oldItems","mapper","initialIndex","_obsArray","_isLive","_onArrayChange","index","idx","obsHolder","_computed_queue_1","_computed_queue_2","_onChange","prev","emit","_disposeOwned","setChangeCB","pureComputed","PureComputed","_useFunc","emptyArray","_dependencies","_inCall","_onListenerChange","_activate","readArgs","apply","keyframes","styled","creator","styles","StylePiece","newCreator","addToElem","KeyframePiece","_global","_styles","_mounted","_nextClassName","_unmounted","g","_grainNextStyleNum","getNextStyleNum","sheet","from","_createRules","join","head","piece","_mountAll","nestedStart","search","createCssRules","kowrap_1","_depItem","_evaluate","_depListeners","_subscribeTo","_dynDeps","Map","_useDependency","values","_obs","listener","_inUse","useDep","_enqueue","enqueue","bindBU","bindUB","bindB","input","index_1","options","isValid","setValue","validity","valid","checkValidity","onInput","Enter","select","unwrapMaybeObsArray","array","getOptionValue","option","optionArray","defLabel","label","disabled","selected","obsValue","findIndex","selectedIndex"],"mappings":"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","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./lib/binding\"), exports);\n__exportStar(require(\"./lib/computed\"), exports);\n__exportStar(require(\"./lib/dispose\"), exports);\n__exportStar(require(\"./lib/dom\"), exports);\n__exportStar(require(\"./lib/emit\"), exports);\n__exportStar(require(\"./lib/kowrap\"), exports);\n__exportStar(require(\"./lib/obsArray\"), exports);\n__exportStar(require(\"./lib/observable\"), exports);\n__exportStar(require(\"./lib/pureComputed\"), exports);\n__exportStar(require(\"./lib/styled\"), exports);\n__exportStar(require(\"./lib/subscribe\"), exports);\n__exportStar(require(\"./lib/util\"), exports);\n__exportStar(require(\"./lib/widgets/input\"), exports);\n__exportStar(require(\"./lib/widgets/select\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n/**\n * A simple and fast priority queue with a limited interface to push, pop, peek, and get size. It\n * is essentially equivalent to both npm modules 'fastpriorityqueue' and 'qheap', but is in\n * TypeScript and is a bit cleaner and simpler.\n *\n * It is constructed with a function that returns which of two items is \"prior\"; the pop() method\n * returns the most-prior element.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PriorityQueue = void 0;\nclass PriorityQueue {\n    constructor(_isPrior) {\n        this._isPrior = _isPrior;\n        // Items form a binary tree packed into an array. Root is items[0]; children of items[i] are\n        // items[2*i+1] and items[2*i+2]; parent of items[i] is items[(i - 1) >> 1]. For all children,\n        // the invariant isPrior(parent, child) holds.\n        this._items = [];\n    }\n    get size() { return this._items.length; }\n    push(item) {\n        const items = this._items;\n        const isPrior = this._isPrior;\n        let curIdx = this._items.length;\n        while (curIdx > 0) {\n            // While we have a parent that is not prior to us, bubble up the \"hole\" at items.length.\n            const parIdx = (curIdx - 1) >> 1; // tslint:disable-line:no-bitwise\n            const parItem = items[parIdx];\n            if (isPrior(parItem, item)) {\n                break;\n            }\n            items[curIdx] = parItem;\n            curIdx = parIdx;\n        }\n        items[curIdx] = item;\n    }\n    peek() {\n        return this._items[0];\n    }\n    pop() {\n        if (this._items.length <= 1) {\n            return this._items.pop();\n        }\n        const items = this._items;\n        const isPrior = this._isPrior;\n        const result = items[0];\n        // Bubble the last item downwards from the root.\n        const item = items.pop();\n        const size = this._items.length;\n        let curIdx = 0;\n        let leftIdx = 1;\n        while (leftIdx < size) {\n            const rightIdx = leftIdx + 1;\n            const bestIdx = (rightIdx < size && isPrior(items[rightIdx], items[leftIdx])) ?\n                rightIdx : leftIdx;\n            if (isPrior(item, items[bestIdx])) {\n                break;\n            }\n            items[curIdx] = items[bestIdx];\n            curIdx = bestIdx;\n            leftIdx = curIdx + curIdx + 1;\n        }\n        items[curIdx] = item;\n        return result;\n    }\n}\nexports.PriorityQueue = PriorityQueue;\n//# sourceMappingURL=PriorityQueue.js.map","\"use strict\";\n/**\n * This module supports computed observables, organizing them into a priority queue, so that\n * computeds can be updated just once after multiple bundled changes.\n *\n * This module is for internal use only (hence the leading underscore in the name). The only\n * function useful outside is exposed via the `observable` module as `observable.bundleChanges()`.\n *\n * Changes may come together because multiple observables are changed synchronously, or because\n * multiple computeds depend on a single changed observable. In either case, if a computed depends\n * on multiple observables that are being changed, we want it to just get updated once when the\n * changes are complete.\n *\n * This is done by maintaining a _priority in each computed, where greater values get evaluated\n * later (computed with greater values depend on those with smaller values). When a computed needs\n * updating, it adds itself to the queue using enqueue() method. At the end of an observable.set()\n * call, or of bundleChanges() call, the queue gets processed in order of _priority.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bundleChanges = exports.compute = exports._getPriority = exports.DepItem = void 0;\nconst PriorityQueue_1 = require(\"./PriorityQueue\");\n/**\n * DepItem is an item in a dependency relationship. It may depend on other DepItems. It is used\n * for subscriptions and computed observables.\n */\nclass DepItem {\n    /**\n     * Callback should call depItem.useDep(dep) for each DepInput it depends on.\n     */\n    constructor(callback, optContext) {\n        this._priority = 0;\n        this._enqueued = false;\n        // Order of creation, used for ordering items at same priority.\n        this._creation = ++_nextCreationNum;\n        this._callback = callback;\n        this._context = optContext;\n    }\n    static isPrioritySmaller(a, b) {\n        return a._priority < b._priority || (a._priority === b._priority && a._creation < b._creation);\n    }\n    /**\n     * Mark depItem as a dependency of this DepItem. The argument may be null to indicate a leaf (an\n     * item such as a plain observable, which does not itself depend on anything else).\n     */\n    useDep(depItem) {\n        const p = depItem ? depItem._priority : 0;\n        if (p >= this._priority) {\n            this._priority = p + 1;\n        }\n    }\n    /**\n     * Recompute this DepItem, calling the callback given in the constructor.\n     */\n    recompute() {\n        this._priority = 0;\n        this._callback.call(this._context);\n    }\n    /**\n     * Add this DepItem to the queue, to be recomputed when the time is right.\n     */\n    enqueue() {\n        if (!this._enqueued) {\n            this._enqueued = true;\n            queue.push(this);\n        }\n    }\n}\nexports.DepItem = DepItem;\n// The main compute queue.\nconst queue = new PriorityQueue_1.PriorityQueue(DepItem.isPrioritySmaller);\n// Counter for creation order, used to create a stable ordering of DepItems at same priority.\nlet _nextCreationNum = 0;\n// Array to keep track of items recomputed during this call to compute(). It could be a local\n// variable in compute(), but is made global to minimize allocations.\nconst _seen = [];\n// Counter used for bundling multiple calls to compute() into one.\nlet bundleDepth = 0;\n/**\n * Exposed for unittests. Returns the internal priority value of an observable.\n */\nfunction _getPriority(obs) {\n    const depItem = obs._getDepItem();\n    return depItem ? depItem._priority : 0;\n}\nexports._getPriority = _getPriority;\n/**\n * Update any computed observables that need updating. The update is deferred if we are currently\n * in the middle of a bundle. This is called automatically whenever you set an observable, and\n * there should be no need to ever call this by users of the library.\n */\nfunction compute() {\n    if (bundleDepth === 0 && queue.size > 0) {\n        // Prevent nested compute() calls, which are unnecessary and can cause deep recursion stack.\n        bundleDepth++;\n        try {\n            // We reuse _seen array to minimize allocations, but always leave it empty.\n            do {\n                const item = queue.pop();\n                _seen.push(item);\n                item.recompute();\n            } while (queue.size > 0);\n        }\n        finally {\n            // We delay the unsetting of _enqueued flag to here, to protect against infinite loops when\n            // a change to a computed causes it to get enqueued again.\n            for (const item of _seen) {\n                item._enqueued = false;\n            }\n            _seen.length = 0;\n            bundleDepth--;\n        }\n    }\n}\nexports.compute = compute;\n/**\n * Defer recomputations of all computed observables and subscriptions until func() returns. This\n * is useful to avoid unnecessary recomputation if you are making several changes to observables\n * together. This function is exposed as `observable.bundleChanges()`.\n *\n * Note that this intentionally does not wait for promises to be resolved, since that would block\n * all updates to all computeds while waiting.\n */\nfunction bundleChanges(func) {\n    try {\n        bundleDepth++;\n        return func();\n    }\n    finally {\n        bundleDepth--;\n        compute();\n    }\n}\nexports.bundleChanges = bundleChanges;\n//# sourceMappingURL=_computed_queue.js.map","\"use strict\";\n/**\n * binding.ts offers a convenient subscribe() function that creates a binding to an observable, a\n * a plain value, or a function from which it builds a computed.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subscribeElem = exports.subscribeBindable = void 0;\nconst computed_1 = require(\"./computed\");\nconst domDispose_1 = require(\"./domDispose\");\nconst observable_1 = require(\"./observable\");\nconst subscribe_1 = require(\"./subscribe\");\nfunction subscribeBindable(valueObs, callback) {\n    // A plain function (to make a computed from), or a knockout observable.\n    if (typeof valueObs === 'function') {\n        // Knockout observable.\n        const koValue = valueObs;\n        if (typeof koValue.peek === 'function') {\n            const sub = koValue.subscribe((val) => callback(val));\n            callback(koValue.peek());\n            return sub;\n        }\n        // Function from which to make a computed. Note that this is also reasonable:\n        //    let sub = subscribe(use => callback(valueObs(use)));\n        // The difference is that when valueObs() evaluates to unchanged value, callback would be\n        // called in the version above, but not in the version below.\n        const comp = computed_1.computed(valueObs);\n        comp.addListener((val) => callback(val));\n        callback(comp.get());\n        return comp; // Disposing this will dispose its one listener.\n    }\n    // An observable.\n    if (valueObs instanceof observable_1.BaseObservable) {\n        // Use subscribe() rather than addListener(), so that bundling of changes (implicit and with\n        // bundleChanges()) is respected. This matters when callback also uses observables.\n        return subscribe_1.subscribe(valueObs, (use, val) => callback(val));\n    }\n    callback(valueObs);\n    return null;\n}\nexports.subscribeBindable = subscribeBindable;\n/**\n * Subscribes a callback to valueObs (which may be a value, observable, or function) using\n * subscribe(), and disposes the subscription with the passed-in element.\n */\nfunction subscribeElem(elem, valueObs, callback) {\n    domDispose_1.autoDisposeElem(elem, subscribeBindable(valueObs, callback));\n}\nexports.subscribeElem = subscribeElem;\n//# sourceMappingURL=binding.js.map","\"use strict\";\n/**\n * Module that allows client-side code to use browser globals (such as `document` or `Node`) in a\n * way that allows those globals to be replaced by mocks in browser-less tests.\n *\n *    import {G} from 'browserGlobals';\n *    ... use G.document\n *    ... use G.Node\n *\n * Initially, the global `window` object, is the source of the global values.\n *\n * To use a mock of globals in a test, use:\n *\n *    import {pushGlobals, popGlobals} as G from 'browserGlobals';\n *    before(function() {\n *      pushGlobals(mockWindow);    // e.g. jsdom.jsdom(...).defaultView\n *    });\n *    after(function() {\n *      popGlobals();\n *    });\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.popGlobals = exports.pushGlobals = exports.G = void 0;\n;\nfunction _updateGlobals(dest, source) {\n    dest.DocumentFragment = source.DocumentFragment;\n    dest.Element = source.Element;\n    dest.Node = source.Node;\n    dest.document = source.document;\n    dest.window = source.window;\n}\n// The initial IBrowserGlobals object.\nconst initial = {};\n_updateGlobals(initial, (typeof window !== 'undefined' ? window : {}));\n// The globals G object strats out with a copy of `initial`.\nexports.G = Object.assign({}, initial);\n// The stack of globals that always has the intial object, but which may be overridden.\nconst _globalsStack = [initial];\n/**\n * Replace globals with those from the given object. Use popGlobals() to restore previous values.\n */\nfunction pushGlobals(globals) {\n    _globalsStack.push(globals);\n    _updateGlobals(exports.G, globals);\n}\nexports.pushGlobals = pushGlobals;\n/**\n * Restore the values of globals to undo the preceding pushGlobals() call.\n */\nfunction popGlobals() {\n    if (_globalsStack.length > 1) {\n        _globalsStack.pop();\n    }\n    _updateGlobals(exports.G, _globalsStack[_globalsStack.length - 1]);\n}\nexports.popGlobals = popGlobals;\n//# sourceMappingURL=browserGlobals.js.map","\"use strict\";\n/**\n * computed.js implements a computed observable, whose value depends on other observables and gets\n * recalculated automatically when they change.\n *\n * E.g. if we have some existing observables (which may themselves be instances of `computed`),\n * we can create a computed that subscribes to them explicitly:\n *  let obs1 = observable(5), obs2 = observable(12);\n *  let computed1 = computed(obs1, obs2, (use, v1, v2) => v1 + v2);\n *\n * or implicitly by using `use(obs)` function:\n *  let computed2 = computed(use => use(obs1) + use(obs2));\n *\n * In either case, computed1.get() and computed2.get() will have the value 17. If obs1 or obs2 is\n * changed, computed1 and computed2 will get recomputed automatically.\n *\n * Creating a computed allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the read() callback. These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *  let val = computed(...deps, ((use, ...depValues) => READ_CALLBACK));\n *\n * You may specify a `write` callback by calling `onWrite(WRITE_CALLBACK)`, which will be called\n * whenever set() is called on the computed by its user. If a `write` bacllback is not specified,\n * calling `set` on a computed observable will throw an exception.\n *\n * Note that pureComputed.js offers a variation of computed() with the same interface, but which\n * stays unsubscribed from dependencies while it itself has no subscribers.\n *\n * A computed may be used with a disposable value using `use.owner` as the value's owner. E.g.\n *    let val = computed((use) => Foo.create(use.owner, use(a), use(b)));\n *\n * When the computed() is re-evaluated, and when it itself is disposed, it disposes the previously\n * owned value. Note that only the pattern above works, i.e. use.owner may only be used to take\n * ownership of the same disposable that the callback returns.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computed = exports.Computed = void 0;\nconst dispose_1 = require(\"./dispose\");\nconst observable_1 = require(\"./observable\");\nconst subscribe_1 = require(\"./subscribe\");\nfunction _noWrite() {\n    throw new Error(\"Can't write to non-writable computed\");\n}\nclass Computed extends observable_1.Observable {\n    /**\n     * Internal constructor for a Computed observable. You should use computed() function instead.\n     */\n    constructor(callback, dependencies) {\n        // At initialization we force an undefined value even though it's not of type T: it gets set\n        // to a proper value during the creation of new Subscription, which calls this._read.\n        super(undefined);\n        this._callback = callback;\n        this._write = _noWrite;\n        this._sub = new subscribe_1.Subscription(this._read.bind(this), dependencies, this);\n    }\n    /**\n     * Creates a new Computed, owned by the given owner.\n     * @param owner: Object to own this Computed, or null to handle disposal manually.\n     * @param ...observables: Zero or more observables on which this computes depends. The callback\n     *        will get called when any of these changes.\n     * @param callback: Read callback that will be called with (use, ...values),\n     *    i.e. the `use` function and values for all of the ...observables. The callback is called\n     *    immediately and whenever any dependency changes.\n     * @returns {Computed} The newly created computed observable.\n     */\n    static create(owner, ...args) {\n        const readCb = args.pop();\n        return dispose_1.setDisposeOwner(owner, new Computed(readCb, args));\n    }\n    /**\n     * Used by subscriptions to keep track of dependencies.\n     */\n    _getDepItem() {\n        return this._sub._getDepItem();\n    }\n    /**\n     * \"Sets\" the value of the computed by calling the write() callback if one was provided in the\n     * constructor. Throws an error if there was no such callback (not a \"writable\" computed).\n     * @param {Object} value: The value to pass to the write() callback.\n     */\n    set(value) { this._write(value); }\n    /**\n     * Set callback to call when this.set(value) is called, to make it a writable computed. If not\n     * set, attempting to write to this computed will throw an exception.\n     */\n    onWrite(writeFunc) {\n        this._write = writeFunc;\n        return this;\n    }\n    /**\n     * Disposes the computed, unsubscribing it from all observables it depends on.\n     */\n    dispose() {\n        this._sub.dispose();\n        super.dispose();\n    }\n    _read(use, ...args) {\n        super.set(this._callback(use, ...args));\n    }\n}\nexports.Computed = Computed;\n/**\n * Creates a new Computed.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the read() callback\n *    will be called with the values of these observables as arguments.\n * @param {Function} readCallback: Read callback that will be called with (use, ...values),\n *    i.e. the `use` function and values for all of the ...observables. The callback is called\n *    immediately and whenever any dependency changes.\n * @returns {Computed} The newly created computed observable.\n */\nfunction computed(...args) {\n    const readCb = args.pop();\n    return new Computed(readCb, args);\n}\nexports.computed = computed;\n// TODO Consider implementing .singleUse() method.\n// An open question is in how to pass e.g. kd.hide(computed(x, x => !x)) in such a way that\n// the temporary computed can be disposed when temporary, but not otherwise. A function-only\n// syntax is kd.hide(use => !use(x)), but prevents use of static subscriptions.\n//\n// (a) function-only use of computeds is fine and useful.\n// (b) pureComputed is another option, and doesn't technically require getting disposed.\n// (c) kd.hide(compObs), kd.autoDispose(compObs) is more general and\n//     can be replaced more concisely by kd.hide(compObs.singleUse())\n// .singleUse() automatically disposes a computed (or an observable?) once there are no\n// subscriptions to it. If there are no subscriptions at the time of this call, waits for the next\n// tick, and possibly disposes then.\n//# sourceMappingURL=computed.js.map","\"use strict\";\n/**\n * dispose.js provides tools to objects that needs to dispose resources, such as destroy DOM, and\n * unsubscribe from events. The motivation with examples is presented here:\n *\n *    https://phab.getgrist.com/w/disposal/\n *\n * Disposable is a class for components that need cleanup (e.g. maintain DOM, listen to events,\n * subscribe to anything). It provides a .dispose() method that should be called to destroy the\n * component, and .onDispose()/.autoDispose() methods that the component should use to take\n * responsibility for other pieces that require cleanup.\n *\n * To define a disposable class:\n *    class Foo extends Disposable { ... }\n *\n * To create Foo:\n *    const foo = Foo.create(owner, ...args);\n * This is better than `new Foo` for two reasons:\n *    1. If Foo's constructor throws an exception, any disposals registered in that constructor\n *       before the exception are honored.\n *    2. It ensures you specify the owner of the new instance (but you can use null to skip it).\n *\n * In Foo's constructor (or rarely methods), take ownership of other Disposable objects:\n *    this.bar = Bar.create(this, ...);\n *\n * For objects that are not instances of Disposable but have a .dispose() methods, use:\n *    this.bar = this.autoDispose(createSomethingDisposable());\n *\n * To call a function on disposal (e.g. to add custom disposal logic):\n *    this.onDispose(() => this.myUnsubscribeAllMethod());\n *    this.onDispose(this.myUnsubscribeAllMethod, this);    // slightly more efficient\n *\n * To mark this object to be wiped out on disposal (i.e. set all properties to null):\n *    this.wipeOnDispose();\n * See the documentation of that method for more info.\n *\n * To dispose Foo directly:\n *    foo.dispose();\n * To determine if an object has already been disposed:\n *    foo.isDisposed()\n *\n * If you need to replace an owned object, or release, or dispose it early, use a Holder:\n *    this._holder = Holder.create(this);\n *    Bar.create(this._holder, 1);      // creates new Bar(1)\n *    Bar.create(this._holder, 2);      // creates new Bar(2) and disposes previous object\n *    this._holder.clear();             // disposes contained object\n *    this._holder.release();           // releases contained object\n *\n * If you need a container for multiple objects and dispose them all together, use a MultiHolder:\n *    this._mholder = MultiHolder.create(null);\n *    Bar.create(this._mholder, 1);     // create new Bar(1)\n *    Bar.create(this._mholder, 2);     // create new Bar(2)\n *    this._mholder.dispose();          // disposes both objects\n *\n * If creating your own class with a dispose() method, do NOT throw exceptions from dispose().\n * These cannot be handled properly in all cases. Read here about the same issue in C++:\n *    http://bin-login.name/ftp/pub/docs/programming_languages/cpp/cffective_cpp/MAGAZINE/SU_FRAME.HTM#destruct\n *\n * Using a parametrized (generic) class as a Disposable is tricky. E.g.\n *    class Bar<T> extends Disposable { ... }\n *    // Bar<T>.create(...)   <-- doesn't work\n *    // Bar.create<T>(...)   <-- doesn't work\n *    // Bar.create(...)      <-- works, but with {} for Bar's type parameters\n *\n * The solution is to expose the constructor type using a helper method:\n *    class Bar<T> extends Disposable {\n *      // Note the tuple below which must match the constructor parameters of Bar<U>.\n *      public static ctor<U>(): IDisposableCtor<Bar<U>, [U, boolean]> { return this; }\n *      constructor(a: T, b: boolean) { ... }\n *    }\n *    Bar.ctor<T>().create(...)   // <-- works, creates Bar<T>, and does type-checking!\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setDisposeOwner = exports.MultiHolder = exports.Holder = exports.Disposable = void 0;\nconst emit_1 = require(\"./emit\");\n// Internal \"owner\" of disposable objects which doesn't actually dispose or keep track of them. It\n// is the effective owner when creating a Disposable with `new Foo()` rather than `Foo.create()`.\nconst _noopOwner = {\n    autoDispose(obj) { },\n};\n// Newly-created Disposable instances will have this as their owner. This is not a constant, it\n// is used by create() for the safe creation of Disposables.\nlet _defaultDisposableOwner = _noopOwner;\n/**\n * Base class for disposable objects that can own other objects. See the module documentation.\n */\nclass Disposable {\n    constructor() {\n        this._disposalList = new DisposalList();\n        // This registers with a temp Holder when using create(), and is a no-op when using `new Foo`.\n        _defaultDisposableOwner.autoDispose(this);\n        // Be sure to reset to no-op, so that a (non-recommended) direct call like 'new Bar()', from\n        // inside Foo's constructor doesn't use the same Holder that's temporarily holding Foo.\n        _defaultDisposableOwner = _noopOwner;\n    }\n    /**\n     * Create Disposable instances using `Class.create(owner, ...)` rather than `new Class(...)`.\n     *\n     * This reminds you to provide an owner, and ensures that if the constructor throws an\n     * exception, dispose() gets called to clean up the partially-constructed object.\n     *\n     * Owner may be null if intend to ensure disposal some other way.\n     */\n    static create(owner, ...args) {\n        const origDefaultOwner = _defaultDisposableOwner;\n        const holder = new Holder();\n        try {\n            // The newly-created object will have holder as its owner.\n            _defaultDisposableOwner = holder;\n            return setDisposeOwner(owner, new this(...args));\n        }\n        catch (e) {\n            try {\n                // This calls dispose on the partially-constructed object\n                holder.clear();\n            }\n            catch (e2) {\n                // tslint:disable-next-line:no-console\n                console.error(\"Error disposing partially constructed %s:\", this.name, e2);\n            }\n            throw e;\n        }\n        finally {\n            // On success, the new object has a new owner, and we release it from holder.\n            // On error, the holder has been cleared, and the release() is a no-op.\n            holder.release();\n            _defaultDisposableOwner = origDefaultOwner;\n        }\n    }\n    /** Take ownership of obj, and dispose it when this.dispose() is called. */\n    autoDispose(obj) {\n        this.onDispose(obj.dispose, obj);\n        return obj;\n    }\n    /** Call the given callback when this.dispose() is called. */\n    onDispose(callback, context) {\n        return this._disposalList.addListener(callback, context);\n    }\n    /**\n     * Wipe out this object when it is disposed, i.e. set all its properties to null. It is\n     * recommended to call this early in the constructor.\n     *\n     * This makes disposal more costly, but has certain benefits:\n     * - If anything still refers to the object and uses it, we'll get an early error, rather than\n     *   silently keep going, potentially doing useless work (or worse) and wasting resources.\n     * - If anything still refers to the object (even without using it), the fields of the object\n     *   can still be garbage-collected.\n     * - If there are circular references involving this object, they get broken, making the job\n     *   easier for the garbage collector.\n     *\n     * The recommendation is to use it for complex, longer-lived objects, but to skip for objects\n     * which are numerous and short-lived (and less likely to be referenced from unexpected places).\n     */\n    wipeOnDispose() {\n        this.onDispose(this._wipeOutObject, this);\n    }\n    /**\n     * Returns whether this object has already been disposed.\n     */\n    isDisposed() {\n        return this._disposalList === null;\n    }\n    /**\n     * Clean up `this` by disposing all owned objects, and calling onDispose() callbacks, in reverse\n     * order to that in which they were added.\n     */\n    dispose() {\n        const disposalList = this._disposalList;\n        if (!disposalList) {\n            // tslint:disable-next-line:no-console\n            console.error(\"Error disposing %s which is already disposed\", _describe(this));\n        }\n        else {\n            this._disposalList = null;\n            disposalList.callAndDispose(this);\n        }\n    }\n    /**\n     * Wipe out this object by setting each property to null. This is helpful for objects that are\n     * disposed and should be ready to be garbage-collected.\n     */\n    _wipeOutObject() {\n        // The sentinel value doesn't have to be null, but some values cause more helpful errors than\n        // others. E.g. if a.x = \"disposed\", then a.x.foo() throws \"undefined is not a function\", but\n        // when a.x = null, a.x.foo() throws a more helpful \"Cannot read property 'foo' of null\".\n        for (const k of Object.keys(this)) {\n            this[k] = null;\n        }\n    }\n}\nexports.Disposable = Disposable;\n/**\n * Holder keeps a single disposable object. If given responsibility for another object using\n * holder.autoDispose() or Foo.create(holder, ...), it automatically disposes the currently held\n * object. It also disposes it when the holder itself is disposed.\n *\n * If the object is an instance of Disposable, the holder will also notice when the object gets\n * disposed from outside of it, in which case the holder will become empty again.\n */\nclass Holder {\n    constructor() {\n        this._owned = null;\n        this._disposalListener = undefined;\n    }\n    static create(owner) {\n        return setDisposeOwner(owner, new Holder());\n    }\n    /** Take ownership of a new object, disposing the previously held one. */\n    autoDispose(obj) {\n        this.clear();\n        this._owned = obj;\n        if (obj instanceof Disposable) {\n            this._disposalListener = obj.onDispose(this._onOutsideDispose, this);\n        }\n        return obj;\n    }\n    /** Releases the held object without disposing it, emptying the holder. */\n    release() {\n        this._unlisten();\n        const ret = this._owned;\n        this._owned = null;\n        return ret;\n    }\n    /** Disposes the held object and empties the holder. */\n    clear() {\n        this._unlisten();\n        const owned = this._owned;\n        if (owned) {\n            this._owned = null;\n            owned.dispose();\n        }\n    }\n    /** Returns the held object, or null if the Holder is empty. */\n    get() { return this._owned; }\n    /** Returns whether the Holder is empty. */\n    isEmpty() { return !this._owned; }\n    /** When the holder is disposed, it disposes the held object if any. */\n    dispose() { this.clear(); }\n    /** Stop listening for the disposal of this._owned. */\n    _unlisten() {\n        const disposalListener = this._disposalListener;\n        if (disposalListener) {\n            this._disposalListener = undefined;\n            disposalListener.dispose();\n        }\n    }\n    _onOutsideDispose() {\n        this._disposalListener = undefined;\n        this._owned = null;\n    }\n}\nexports.Holder = Holder;\n/**\n * MultiHolder keeps multiple disposable object. It disposes all held object when the holder\n * itself is disposed. It's actually nothing more than the Disposable base class itself, just\n * exposed with a clearer name that describes its purpose.\n */\nclass MultiHolder extends Disposable {\n}\nexports.MultiHolder = MultiHolder;\n/**\n * Sets owner of obj (i.e. calls owner.autoDispose(obj)) unless owner is null. Returns obj.\n */\nfunction setDisposeOwner(owner, obj) {\n    if (owner) {\n        owner.autoDispose(obj);\n    }\n    return obj;\n}\nexports.setDisposeOwner = setDisposeOwner;\n/**\n * Helper for reporting errors during disposal. Try to report the type of the object.\n */\nfunction _describe(obj) {\n    return (obj && obj.constructor && obj.constructor.name ? obj.constructor.name : '' + obj);\n}\n/**\n * DisposalList is an internal class mimicking emit.Emitter. The difference is that callbacks are\n * called in reverse order, and exceptions in callbacks are reported and swallowed.\n */\nclass DisposalList extends emit_1.LLink {\n    constructor() { super(); }\n    addListener(callback, optContext) {\n        const lis = new DisposeListener(callback, optContext);\n        this._insertBefore(this._next, lis);\n        return lis;\n    }\n    /**\n     * Call all callbacks and dispose this object. The owner is required for better reporting of\n     * errors if any callback throws.\n     */\n    callAndDispose(owner) {\n        try {\n            DisposeListener.callAll(this._next, this, owner);\n        }\n        finally {\n            this._disposeList();\n        }\n    }\n}\n/**\n * Internal class that keeps track of one item of the DisposalList. It mimicks emit.Listener, but\n * reports and swallows erros when it calls the callbacks in the list.\n */\nclass DisposeListener extends emit_1.LLink {\n    constructor(callback, context) {\n        super();\n        this.callback = callback;\n        this.context = context;\n    }\n    static callAll(begin, end, owner) {\n        while (begin !== end) {\n            const lis = begin;\n            try {\n                lis.callback.call(lis.context);\n            }\n            catch (e) {\n                // tslint:disable-next-line:no-console\n                console.error(\"While disposing %s, error disposing %s: %s\", _describe(owner), _describe(this), e);\n            }\n            begin = lis._next;\n        }\n    }\n    dispose() {\n        if (this.isDisposed()) {\n            return;\n        }\n        this._removeNode(this);\n    }\n}\n//# sourceMappingURL=dispose.js.map","\"use strict\";\n/**\n * dom.js provides a way to build a DOM tree easily.\n *\n * E.g.\n *  import {dom} from 'grainjs';\n *  dom('a#link.c1.c2', {'href': url}, 'Hello ', dom('span', 'world'));\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>.\n *\n *  dom.frag(dom('span', 'Hello'), ['blah', dom('div', 'world')])\n *    creates document fragment with <span>Hello</span>blah<div>world</div>.\n *\n * DOM can also be created and modified inline during creation:\n *  dom('a#id.c1',\n *      dom.cls('c2'), dom.attr('href', url),\n *      dom.text('Hello '), dom('span', dom.text('world')))\n *    creates Node <a id=\"link\" class=\"c1 c2\" href={{url}}Hello <span>world</span></a>,\n *    identical to the first example above.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dom = void 0;\n// We keep various dom-related functions organized in private modules, but they are exposed here.\n__exportStar(require(\"./domImpl\"), exports);\n__exportStar(require(\"./domComponent\"), exports);\n__exportStar(require(\"./domComputed\"), exports);\n__exportStar(require(\"./domDispose\"), exports);\n__exportStar(require(\"./domForEach\"), exports);\n__exportStar(require(\"./domMethods\"), exports);\n__exportStar(require(\"./domevent\"), exports);\nconst _domComponent = require(\"./domComponent\");\nconst _domComputed = require(\"./domComputed\");\nconst _domDispose = require(\"./domDispose\");\nconst _domForEach = require(\"./domForEach\");\nconst _domImpl = require(\"./domImpl\");\nconst _domMethods = require(\"./domMethods\");\nconst domevent = require(\"./domevent\");\nconst domImpl_1 = require(\"./domImpl\");\n// We just want to re-export _domImpl.dom, but to allow adding methods to it in a typesafe way,\n// TypeScript wants us to declare a real function in the same file.\nfunction dom(tagString, ...args) {\n    return domImpl_1.dom(tagString, ...args);\n}\nexports.dom = dom;\n// Additionally export all methods as properties of dom() function.\n(function (dom) {\n    dom.svg = _domImpl.svg;\n    dom.frag = _domImpl.frag;\n    dom.update = _domImpl.update;\n    dom.find = _domImpl.find;\n    dom.findAll = _domImpl.findAll;\n    dom.domDispose = _domDispose.domDispose;\n    dom.onDisposeElem = _domDispose.onDisposeElem;\n    dom.onDispose = _domDispose.onDispose;\n    dom.autoDisposeElem = _domDispose.autoDisposeElem;\n    dom.autoDispose = _domDispose.autoDispose;\n    dom.attrsElem = _domMethods.attrsElem;\n    dom.attrs = _domMethods.attrs;\n    dom.attrElem = _domMethods.attrElem;\n    dom.attr = _domMethods.attr;\n    dom.boolAttrElem = _domMethods.boolAttrElem;\n    dom.boolAttr = _domMethods.boolAttr;\n    dom.textElem = _domMethods.textElem;\n    dom.text = _domMethods.text;\n    dom.styleElem = _domMethods.styleElem;\n    dom.style = _domMethods.style;\n    dom.propElem = _domMethods.propElem;\n    dom.prop = _domMethods.prop;\n    dom.showElem = _domMethods.showElem;\n    dom.show = _domMethods.show;\n    dom.hideElem = _domMethods.hideElem;\n    dom.hide = _domMethods.hide;\n    dom.clsElem = _domMethods.clsElem;\n    dom.cls = _domMethods.cls;\n    dom.clsPrefix = _domMethods.clsPrefix;\n    dom.dataElem = _domMethods.dataElem;\n    dom.data = _domMethods.data;\n    dom.getData = _domMethods.getData;\n    dom.replaceContent = _domComputed.replaceContent;\n    dom.domComputed = _domComputed.domComputed;\n    dom.domComputedOwned = _domComputed.domComputedOwned;\n    dom.maybe = _domComputed.maybe;\n    dom.maybeOwned = _domComputed.maybeOwned;\n    dom.forEach = _domForEach.forEach;\n    dom.create = _domComponent.create;\n    dom.onElem = domevent.onElem;\n    dom.on = domevent.on;\n    dom.onMatchElem = domevent.onMatchElem;\n    dom.onMatch = domevent.onMatch;\n    dom.onKeyElem = domevent.onKeyElem;\n    dom.onKeyPress = domevent.onKeyPress;\n    dom.onKeyDown = domevent.onKeyDown;\n})(dom = exports.dom || (exports.dom = {}));\n//# sourceMappingURL=dom.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create = void 0;\nconst domComputed_1 = require(\"./domComputed\");\nfunction create(fn, ...args) {\n    return domComputed_1.domComputedOwned(null, (owner) => {\n        const value = ('create' in fn) ?\n            fn.create(owner, ...args) :\n            fn(owner, ...args);\n        return (value && typeof value === 'object' && 'buildDom' in value) ?\n            value.buildDom() : value;\n    });\n}\nexports.create = create;\n//# sourceMappingURL=domComponent.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.maybeOwned = exports.maybe = exports.domComputedOwned = exports.domComputed = exports.replaceContent = void 0;\nconst binding_1 = require(\"./binding\");\nconst dispose_1 = require(\"./dispose\");\nconst domDispose_1 = require(\"./domDispose\");\nconst domImpl_1 = require(\"./domImpl\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n/**\n * Replaces the content between nodeBefore and nodeAfter, which should be two siblings within the\n * same parent node. New content may be anything allowed as an argument to dom(), including null\n * to insert nothing. Runs disposers, if any, on all removed content.\n */\nfunction replaceContent(nodeBefore, nodeAfter, content) {\n    const elem = nodeBefore.parentNode;\n    if (elem) {\n        let next;\n        for (let n = nodeBefore.nextSibling; n && n !== nodeAfter; n = next) {\n            next = n.nextSibling;\n            domDispose_1.domDispose(n);\n            elem.removeChild(n);\n        }\n        if (content) {\n            elem.insertBefore(content instanceof browserGlobals_1.G.Node ? content : domImpl_1.frag(content), nodeAfter);\n        }\n    }\n}\nexports.replaceContent = replaceContent;\nfunction domComputed(valueObs, contentFunc = identity) {\n    const markerPre = browserGlobals_1.G.document.createComment('a');\n    const markerPost = browserGlobals_1.G.document.createComment('b');\n    // Function is added after markerPre and markerPost, so that it runs once they have already been\n    // attached to elem (the parent element).\n    return [markerPre, markerPost, (elem) => {\n            binding_1.subscribeElem(markerPost, valueObs, (value) => replaceContent(markerPre, markerPost, contentFunc(value)));\n        }];\n}\nexports.domComputed = domComputed;\n/**\n * Like domComputed(), but the callback gets an additional first argument, owner, which may be\n * used to take ownership of objects created by the callback. These will be disposed before each\n * new call to the callback, and when the containing DOM is disposed.\n *\n *    domComputedOwned(valueObs, (owner, value) => Editor.create(owner, value).renderSomething());\n */\nfunction domComputedOwned(valueObs, contentFunc) {\n    const holder = dispose_1.Holder.create(null);\n    const [markerPre, markerPost, func] = domComputed(valueObs, (val) => contentFunc(dispose_1.MultiHolder.create(holder), val));\n    domDispose_1.autoDisposeElem(markerPost, holder);\n    return [markerPre, markerPost, func];\n}\nexports.domComputedOwned = domComputedOwned;\nfunction identity(arg) { return arg; }\n/**\n * Conditionally appends DOM to an element. The value may be an observable or function (from which\n * a computed is created), whose value -- if truthy -- will be passed to `contentFunc` which\n * should return DOM content. If the value is falsy, DOM content is removed.\n *\n * Note that if the observable changes between different truthy values, contentFunc gets called\n * for each value, and previous content gets destroyed. To consider all truthy values the same,\n * use an observable that returns a proper boolean, e.g.\n *\n *    dom.maybe(use => Boolean(use(fooObs)), () => dom(...));\n *\n * As with domComputed(), dom.maybe() may but should not be used when the argument is not an\n * observable or function. The following are equivalent:\n *\n *    dom(..., dom.maybe(myValue, () => dom(...)));\n *    dom(..., myValue ? dom(...) : null);\n *\n * The latter is preferred for being simpler.\n *\n * @param boolValueObs: Observable or function for a computed.\n * @param contentFunc: Called with the result of boolValueObs when it is truthy. Should return DOM.\n */\nfunction maybe(boolValueObs, contentFunc) {\n    return domComputed(boolValueObs, (value) => value ? contentFunc(value) : null);\n}\nexports.maybe = maybe;\n/**\n * Like maybe(), but the callback gets an additional first argument, owner, which may be used to\n * take ownership of objects created by the callback. These will be disposed before each new call\n * to the callback, and when the condition becomes false or the containing DOM gets disposed.\n *\n *    maybeOwned(showEditor, (owner) => Editor.create(owner).renderSomething());\n */\nfunction maybeOwned(boolValueObs, contentFunc) {\n    return domComputedOwned(boolValueObs, (owner, value) => value ? contentFunc(owner, value) : null);\n}\nexports.maybeOwned = maybeOwned;\n//# sourceMappingURL=domComputed.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.autoDispose = exports.autoDisposeElem = exports.onDispose = exports.onDisposeElem = exports.domDispose = exports.domDisposeHooks = exports._disposeNode = void 0;\n/**\n * Private global disposal map. It maintains the association between DOM nodes and cleanup\n * functions added with dom.onDispose(). To support multiple disposers on one element, we use a\n * WeakMap-based linked list:\n *\n *    _disposeMap[elem] = disposer2;\n *    _disposeMap[disposer2] = disposer1;\n *    etc.\n *\n * This avoids allocating arrays or using undeclared properties for a different linked list.\n */\nconst _disposeMap = new WeakMap();\n// Internal helper to walk the DOM tree, calling visitFunc(elem) on all descendants of elem.\n// Descendants are processed first.\nfunction _walkDom(elem, visitFunc) {\n    let c = elem.firstChild;\n    while (c) {\n        // Note: this might be better done using an explicit stack, but in practice DOM trees aren't\n        // so deep as to cause problems.\n        _walkDom(c, visitFunc);\n        c = c.nextSibling;\n    }\n    visitFunc(elem);\n}\n// Internal helper to run all disposers for a single element.\nfunction _disposeNode(node) {\n    let disposer = _disposeMap.get(node);\n    if (disposer) {\n        let key = node;\n        do {\n            _disposeMap.delete(key);\n            disposer(node);\n            // Find the next disposer; these are chained when there are multiple.\n            key = disposer;\n            disposer = _disposeMap.get(key);\n        } while (disposer);\n    }\n}\nexports._disposeNode = _disposeNode;\nfunction _disposeNodeRecursive(node) {\n    _walkDom(node, exports.domDisposeHooks.disposeNode);\n}\n/**\n * Support for extending dom disposal. This is very low-level, and needs utmost care. Any\n * disposers set should take care of calling the original versions of the disposers.\n */\nexports.domDisposeHooks = {\n    disposeNode: _disposeNode,\n    disposeRecursive: _disposeNodeRecursive,\n};\n/**\n * Run disposers associated with any descendant of elem or with elem itself. Disposers get\n * associated with elements using dom.onDispose(). Descendants are processed first.\n *\n * It is automatically called if one of the function arguments to dom() throws an exception during\n * element creation. This way any onDispose() handlers set on the unfinished element get called.\n *\n * @param {Node} node: The element to run disposers on.\n */\nfunction domDispose(node) {\n    exports.domDisposeHooks.disposeRecursive(node);\n}\nexports.domDispose = domDispose;\n/**\n * Associate a disposerFunc with a DOM element. It will be called when the element is disposed\n * using domDispose() on it or any of its parents. If onDispose is called multiple times, all\n * disposerFuncs will be called in reverse order.\n * @param {Element} elem: The element to associate the disposer with.\n * @param {Function} disposerFunc(elem): Will be called when domDispose() is called on the\n *    element or its ancestor.\n * Note that it is not necessary usually to dispose event listeners attached to an element (e.g.\n * with dom.on()) since their lifetime is naturally limited to the lifetime of the element.\n */\nfunction onDisposeElem(elem, disposerFunc) {\n    const prevDisposer = _disposeMap.get(elem);\n    _disposeMap.set(elem, disposerFunc);\n    if (prevDisposer) {\n        _disposeMap.set(disposerFunc, prevDisposer);\n    }\n}\nexports.onDisposeElem = onDisposeElem;\nfunction onDispose(disposerFunc) {\n    return (elem) => onDisposeElem(elem, disposerFunc);\n}\nexports.onDispose = onDispose;\n/**\n * Make the given element own the disposable, and call its dispose method when domDispose() is\n * called on the element or any of its parents.\n * @param {Element} elem: The element to own the disposable.\n * @param {Disposable} disposable: Anything with a .dispose() method.\n */\nfunction autoDisposeElem(elem, disposable) {\n    if (disposable) {\n        onDisposeElem(elem, () => disposable.dispose());\n    }\n}\nexports.autoDisposeElem = autoDisposeElem;\nfunction autoDispose(disposable) {\n    if (disposable) {\n        return (elem) => autoDisposeElem(elem, disposable);\n    }\n}\nexports.autoDispose = autoDispose;\n//# sourceMappingURL=domDispose.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forEach = void 0;\nconst domComputed_1 = require(\"./domComputed\");\nconst domDispose_1 = require(\"./domDispose\");\nconst domImpl_1 = require(\"./domImpl\");\nconst obsArray_1 = require(\"./obsArray\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n/**\n * Creates DOM elements for each element of an observable array. As the array is changed, children\n * are added or removed. This works for any array-valued observable, and for obsArray() and\n * computedArray() it works more efficiently for simple changes.\n *\n * The given itemCreateFunc() should return a single DOM node for each item, or null to skip that\n * item. It is called for new items whenever they are spliced in, or the array replaced. The\n * forEach() owns the created nodes, and runs domDispose() on them when they are spliced out.\n *\n * If the created nodes are removed from their parent externally, forEach() will cope with it, but\n * will consider these elements as no longer owned, and will not run domDispose() on them.\n *\n * Note that itemCreateFunc() does not receive an index: an index would only be correct at the\n * time the item is created, and would not reflect further changes to the array.\n *\n * If you'd like to map the DOM node back to its source item, use dom.data() and dom.getData() in\n * itemCreateFunc().\n */\nfunction forEach(obsArray, itemCreateFunc) {\n    const markerPre = browserGlobals_1.G.document.createComment('a');\n    const markerPost = browserGlobals_1.G.document.createComment('b');\n    return [markerPre, markerPost, (elem) => {\n            if (Array.isArray(obsArray)) {\n                domComputed_1.replaceContent(markerPre, markerPost, obsArray.map(itemCreateFunc));\n                return;\n            }\n            const nodes = obsArray_1.computedArray(obsArray, itemCreateFunc);\n            // Be sure to dispose the newly-created array when the DOM it's associated with is gone.\n            domDispose_1.autoDisposeElem(markerPost, nodes);\n            nodes.addListener((newArr, oldArr, splice) => {\n                if (splice) {\n                    // Remove the elements that are gone.\n                    for (const node of splice.deleted) {\n                        if (node && node.parentNode === elem) {\n                            domDispose_1.domDispose(node);\n                            elem.removeChild(node);\n                        }\n                    }\n                    if (splice.numAdded > 0) {\n                        // Find a valid child immediately following the spliced out portion, for DOM insertion.\n                        const endIndex = splice.start + splice.numAdded;\n                        let nextElem = markerPost;\n                        for (let i = endIndex; i < newArr.length; i++) {\n                            const node = newArr[i];\n                            if (node && node.parentNode === elem) {\n                                nextElem = node;\n                                break;\n                            }\n                        }\n                        // Insert the new elements.\n                        const content = domImpl_1.frag(newArr.slice(splice.start, endIndex));\n                        elem.insertBefore(content, nextElem);\n                    }\n                }\n                else {\n                    domComputed_1.replaceContent(markerPre, markerPost, newArr);\n                }\n            });\n            domComputed_1.replaceContent(markerPre, markerPost, nodes.get());\n        }];\n}\nexports.forEach = forEach;\n//# sourceMappingURL=domForEach.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAll = exports.find = exports.frag = exports.update = exports.svg = exports.dom = void 0;\nconst domDispose_1 = require(\"./domDispose\");\nconst domMethods_1 = require(\"./domMethods\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n// The goal of the above declarations is to get help from TypeScript in detecting incorrect usage:\n// (See test/types/dom.ts for a test of this.)\n//  import {text, hide} from './domMethods';\n//  dom('div', text('hello'));        // OK\n//  dom('div', hide(true));           // OK\n//  dom('div', {title: 'hello'});     // OK\n//  frag(text('hello'));              // OK\n//  frag(hide(true));                 // Bad: DocumentFragment is not an Element\n//  frag({title: 'hello'});           // Bad: DocumentFragment is not an Element\n/**\n * dom('tag#id.class1.class2', ...args)\n *   The first argument is a string consisting of a tag name, with optional #foo suffix\n *   to add the ID 'foo', and zero or more .bar suffixes to add a CSS class 'bar'.\n *\n *   NOTE that better typings are available when a tag is used directly, e.g.\n *      dom('input', {id: 'foo'}, (elem) => ...) --> elem has type HTMLInputElement\n *      dom('input#foo',          (elem) => ...) --> elem has type HTMLElement\n *\n * The rest of the arguments are optional and may be:\n *\n *   Nodes - which become children of the created element;\n *   strings - which become text node children;\n *   objects - of the form {attr: val} to set additional attributes on the element;\n *   Arrays - which are flattened with each item processed recursively;\n *   functions - which are called with elem as the argument, for a chance to modify the\n *       element as it's being created. Return values are processed recursively.\n *   \"dom methods\" - expressions such as `dom.attr('href', url)` or `dom.hide(obs)`, which\n *       are actually special cases of the \"functions\" category.\n */\nfunction dom(tagString, ...args) {\n    return _updateWithArgsOrDispose(_createFromTagString(_createElementHtml, tagString), args);\n}\nexports.dom = dom;\n/**\n * svg('tag#id.class1.class2', ...args)\n *  Same as dom(...), but creates an SVG element.\n */\nfunction svg(tagString, ...args) {\n    return _updateWithArgsOrDispose(_createFromTagString(_createElementSvg, tagString), args);\n}\nexports.svg = svg;\n// Internal helper used to create HTML elements.\nfunction _createElementHtml(tag) {\n    return browserGlobals_1.G.document.createElement(tag);\n}\n// Internal helper used to create SVG elements.\nfunction _createElementSvg(tag) {\n    return browserGlobals_1.G.document.createElementNS(\"http://www.w3.org/2000/svg\", tag);\n}\n/**\n * Internal helper to parse tagString, create an element using createFunc with the given tag, and\n * set its id and classes from the tagString.\n * @param {Funtion} createFunc(tag): Function that should create an element given a tag name.\n *    It is passed in to allow creating elements in different namespaces (e.g. plain HTML vs SVG).\n * @param {String} tagString: String of the form \"tag#id.class1.class2\" where id and classes are\n *    optional.\n * @return {Element} The result of createFunc(), possibly with id and class attributes also set.\n */\nfunction _createFromTagString(createFunc, tagString) {\n    // We do careful hand-written parsing rather than use a regexp for speed. Using a regexp is\n    // significantly more expensive.\n    let tag;\n    let id;\n    let classes;\n    let dotPos = tagString.indexOf(\".\");\n    const hashPos = tagString.indexOf('#');\n    if (dotPos === -1) {\n        dotPos = tagString.length;\n    }\n    else {\n        classes = tagString.substring(dotPos + 1).replace(/\\./g, ' ');\n    }\n    if (hashPos === -1) {\n        tag = tagString.substring(0, dotPos);\n    }\n    else if (hashPos > dotPos) {\n        throw new Error(`ID must come before classes in dom(\"${tagString}\")`);\n    }\n    else {\n        tag = tagString.substring(0, hashPos);\n        id = tagString.substring(hashPos + 1, dotPos);\n    }\n    const elem = createFunc(tag);\n    if (id) {\n        elem.setAttribute('id', id);\n    }\n    if (classes) {\n        elem.setAttribute('class', classes);\n    }\n    return elem;\n}\n/**\n * Update an element with any number of arguments, as documented in dom().\n */\nfunction update(elem, ...args) {\n    return _updateWithArgs(elem, args);\n}\nexports.update = update;\n/**\n * Update an element with an array of arguments.\n */\nfunction _updateWithArgs(elem, args) {\n    for (const arg of args) {\n        _updateWithArg(elem, arg);\n    }\n    return elem;\n}\n/**\n * Update an element with an array of arguments, calling disposers in case of an exception. It is\n * an internal helper to be used whenever elem is a newly-created element. If elem is an existing\n * element which the user already knows about, then _updateWithArgs should be called.\n */\nfunction _updateWithArgsOrDispose(elem, args) {\n    try {\n        return _updateWithArgs(elem, args);\n    }\n    catch (e) {\n        domDispose_1.domDispose(elem);\n        throw e;\n    }\n}\nfunction _updateWithArg(elem, arg) {\n    if (typeof arg === 'function') {\n        const value = arg(elem);\n        // Skip the recursive call in the common case when the function returns nothing.\n        if (value !== undefined && value !== null) {\n            _updateWithArg(elem, value);\n        }\n    }\n    else if (Array.isArray(arg)) {\n        _updateWithArgs(elem, arg);\n    }\n    else if (arg === undefined || arg === null) {\n        // Nothing to do.\n    }\n    else if (arg instanceof browserGlobals_1.G.Node) {\n        elem.appendChild(arg);\n    }\n    else if (typeof arg === 'object') {\n        domMethods_1.attrsElem(elem, arg);\n    }\n    else {\n        elem.appendChild(browserGlobals_1.G.document.createTextNode(arg));\n    }\n}\n/**\n * Creates a DocumentFragment processing arguments the same way as the dom() function.\n */\nfunction frag(...args) {\n    const elem = browserGlobals_1.G.document.createDocumentFragment();\n    return _updateWithArgsOrDispose(elem, args);\n}\nexports.frag = frag;\n/**\n * Find the first element matching a selector; just an abbreviation for document.querySelector().\n */\nfunction find(selector) { return browserGlobals_1.G.document.querySelector(selector); }\nexports.find = find;\n/**\n * Find all elements matching a selector; just an abbreviation for document.querySelectorAll().\n */\nfunction findAll(selector) { return browserGlobals_1.G.document.querySelectorAll(selector); }\nexports.findAll = findAll;\n//# sourceMappingURL=domImpl.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.noTestId = exports.makeTestId = exports.getData = exports.data = exports.dataElem = exports.clsPrefix = exports.cls = exports.clsElem = exports.hide = exports.hideElem = exports.show = exports.showElem = exports.prop = exports.propElem = exports.style = exports.styleElem = exports.text = exports.textElem = exports.boolAttr = exports.boolAttrElem = exports.attr = exports.attrElem = exports.attrs = exports.attrsElem = void 0;\nconst binding_1 = require(\"./binding\");\nconst domDispose_1 = require(\"./domDispose\");\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\n/**\n * Private global map for associating arbitrary data with DOM. It's a WeakMap, so does not prevent\n * values from being garbage collected when the owning DOM elements are no longer used.\n */\nconst _dataMap = new WeakMap();\n/**\n * Sets multiple attributes of a DOM element. The `attrs()` variant takes no `elem` argument.\n * Null and undefined values are omitted, and booleans are either omitted or set to empty string.\n * @param {Object} attrsObj: Object mapping attribute names to attribute values.\n */\nfunction attrsElem(elem, attrsObj) {\n    for (const key of Object.keys(attrsObj)) {\n        const val = attrsObj[key];\n        if (val != null && val !== false) {\n            elem.setAttribute(key, val === true ? '' : val);\n        }\n    }\n}\nexports.attrsElem = attrsElem;\nfunction attrs(attrsObj) {\n    return (elem) => attrsElem(elem, attrsObj);\n}\nexports.attrs = attrs;\n/**\n * Sets an attribute of a DOM element to the given value. Removes the attribute when the value is\n * null or undefined. The `attr()` variant takes no `elem` argument, and `attrValue` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'href'.\n * @param {String|null} attrValue: The string value or null to remove the attribute.\n */\nfunction attrElem(elem, attrName, attrValue) {\n    if (attrValue === null || attrValue === undefined) {\n        elem.removeAttribute(attrName);\n    }\n    else {\n        elem.setAttribute(attrName, attrValue);\n    }\n}\nexports.attrElem = attrElem;\nfunction attr(attrName, attrValueObs) {\n    return (elem) => binding_1.subscribeElem(elem, attrValueObs, (val) => attrElem(elem, attrName, val));\n}\nexports.attr = attr;\n/**\n * Sets or removes a boolean attribute of a DOM element. According to the spec, empty string is a\n * valid true value for the attribute, and the false value is indicated by the attribute's absence.\n * The `boolAttr()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} attrName: The name of the attribute to bind, e.g. 'checked'.\n * @param {Boolean} boolValue: Boolean value whether to set or unset the attribute.\n */\nfunction boolAttrElem(elem, attrName, boolValue) {\n    attrElem(elem, attrName, boolValue ? '' : null);\n}\nexports.boolAttrElem = boolAttrElem;\nfunction boolAttr(attrName, boolValueObs) {\n    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => boolAttrElem(elem, attrName, val));\n}\nexports.boolAttr = boolAttr;\n/**\n * Adds a text node to the element. The `text()` variant takes no `elem`, and `value` may be an\n * observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} value: The text value to add.\n */\nfunction textElem(elem, value) {\n    elem.appendChild(browserGlobals_1.G.document.createTextNode(value));\n}\nexports.textElem = textElem;\nfunction text(valueObs) {\n    return (elem) => {\n        const textNode = browserGlobals_1.G.document.createTextNode('');\n        binding_1.subscribeElem(elem, valueObs, (val) => { textNode.nodeValue = val; });\n        elem.appendChild(textNode);\n    };\n}\nexports.text = text;\n/**\n * Sets a style property of a DOM element to the given value. The `style()` variant takes no\n * `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the style property to update, e.g. 'fontWeight'.\n * @param {String} value: The value for the property.\n */\nfunction styleElem(elem, property, value) {\n    elem.style[property] = value;\n}\nexports.styleElem = styleElem;\nfunction style(property, valueObs) {\n    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => styleElem(elem, property, val));\n}\nexports.style = style;\n/**\n * Sets the property of a DOM element to the given value.\n * The `prop()` variant takes no `elem`, and `value` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {String} property: The name of the property to update, e.g. 'disabled'.\n * @param {Object} value: The value for the property.\n */\nfunction propElem(elem, property, value) {\n    elem[property] = value;\n}\nexports.propElem = propElem;\nfunction prop(property, valueObs) {\n    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => propElem(elem, property, val));\n}\nexports.prop = prop;\n/**\n * Shows or hides the element depending on a boolean value. Note that the element must be visible\n * initially (i.e. unsetting style.display should show it).\n * The `show()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to show the element, false to hide it.\n */\nfunction showElem(elem, boolValue) {\n    elem.style.display = boolValue ? '' : 'none';\n}\nexports.showElem = showElem;\nfunction show(boolValueObs) {\n    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => showElem(elem, val));\n}\nexports.show = show;\n/**\n * The opposite of show, hiding the element when boolValue is true.\n * The `hide()` variant takes no `elem`, and `boolValue` may be an observable or function.\n * @param {Element} elem: The element to update.\n * @param {Boolean} boolValue: True to hide the element, false to show it.\n */\nfunction hideElem(elem, boolValue) {\n    elem.style.display = boolValue ? 'none' : '';\n}\nexports.hideElem = hideElem;\nfunction hide(boolValueObs) {\n    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => hideElem(elem, val));\n}\nexports.hide = hide;\n/**\n * Sets or toggles the given css class className.\n */\nfunction clsElem(elem, className, boolValue = true) {\n    elem.classList.toggle(className, Boolean(boolValue));\n}\nexports.clsElem = clsElem;\nfunction cls(className, boolValue) {\n    if (typeof className !== 'string') {\n        return _clsDynamicPrefix('', className);\n    }\n    else if (!boolValue || typeof boolValue === 'boolean') {\n        return (elem) => clsElem(elem, className, boolValue);\n    }\n    else {\n        return (elem) => binding_1.subscribeElem(elem, boolValue, (val) => clsElem(elem, className, val));\n    }\n}\nexports.cls = cls;\nfunction clsPrefix(prefix, className, boolValue) {\n    if (typeof className !== 'string') {\n        return _clsDynamicPrefix(prefix, className);\n    }\n    else {\n        return cls(prefix + className, boolValue);\n    }\n}\nexports.clsPrefix = clsPrefix;\nfunction _clsDynamicPrefix(prefix, className) {\n    return (elem) => {\n        let prevClass = null;\n        binding_1.subscribeElem(elem, className, (name) => {\n            if (prevClass) {\n                elem.classList.remove(prevClass);\n            }\n            prevClass = name ? prefix + name : null;\n            if (prevClass) {\n                elem.classList.add(prevClass);\n            }\n        });\n    };\n}\n/**\n * Associate arbitrary data with a DOM element. The `data()` variant takes no `elem`, and `value`\n * may be an observable or function.\n * @param {Element} elem: The element with which to associate data.\n * @param {String} key: Key to identify this piece of data among others attached to elem.\n * @param {Object} value: Arbitrary value to associate with elem.\n */\nfunction dataElem(elem, key, value) {\n    const obj = _dataMap.get(elem);\n    if (obj) {\n        obj[key] = value;\n    }\n    else {\n        domDispose_1.onDisposeElem(elem, () => _dataMap.delete(elem));\n        _dataMap.set(elem, { [key]: value });\n    }\n}\nexports.dataElem = dataElem;\nfunction data(key, valueObs) {\n    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => dataElem(elem, key, val));\n}\nexports.data = data;\nfunction getData(elem, key) {\n    const obj = _dataMap.get(elem);\n    return obj && obj[key];\n}\nexports.getData = getData;\n/**\n * See documentation for TestId above.\n */\nfunction makeTestId(prefix) {\n    return clsPrefix.bind(null, prefix);\n}\nexports.makeTestId = makeTestId;\n/**\n * See documentation for TestId above.\n */\nconst noTestId = (name) => null;\nexports.noTestId = noTestId;\n//# sourceMappingURL=domMethods.js.map","\"use strict\";\n/**\n * domevent provides a way to listen to DOM events, similar to JQuery's `on()` function. Its\n * methods are also exposed via the dom.js module, as `dom.on()`, etc.\n *\n * It is typically used as an argument to the dom() function:\n *\n *    dom('div', dom.on('click', (event, elem) => { ... }));\n *\n * When the div is disposed, the listener is automatically removed.\n *\n * The underlying interface to listen to an event is this:\n *\n *    let listener = dom.onElem(elem, 'click', (event, elem) => { ... });\n *\n * The callback is called with the event and the element to which it was attached. Unlike in\n * JQuery, the callback's return value is ignored. Use event.stopPropagation() and\n * event.preventDefault() explicitly if needed.\n *\n * To stop listening:\n *\n *    listener.dispose();\n *\n * Disposing the listener returned by .onElem() is the only way to stop listening to an event. You\n * can use autoDispose to stop listening automatically when subscribing in a Disposable object:\n *\n *    this.autoDispose(domevent.onElem(document, 'mouseup', callback));\n *\n * To listen to descendants of an element matching the given selector (what JQuery calls\n * \"delegated events\", see http://api.jquery.com/on/):\n *\n *    dom('div', dom.onMatch('.selector', 'click', (event, elem) => { ... }));\n * or\n *    let lis = domevent.onMatchElem(elem, '.selector', 'click', (event, el) => { ... });\n *\n * In this usage, the element passed to the callback will be a DOM element matching the given\n * selector. If there are multiple matches, the callback is only called for the innermost one.\n *\n * If you need to remove the callback on first call, here's a useful pattern:\n *    let lis = domevent.onElem(elem, 'mouseup', e => { lis.dispose(); other_work(); });\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.onKeyDown = exports.onKeyPress = exports.onKeyElem = exports.onMatch = exports.onMatchElem = exports.on = exports.onElem = void 0;\nfunction _findMatch(inner, outer, selector) {\n    for (let el = inner; el && el !== outer; el = el.parentElement) {\n        if (el.matches(selector)) {\n            return el;\n        }\n    }\n    return null;\n}\nclass DomEventListener {\n    constructor(elem, eventType, callback, useCapture, selector) {\n        this.elem = elem;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.useCapture = useCapture;\n        this.selector = selector;\n        this.elem.addEventListener(this.eventType, this, this.useCapture);\n    }\n    handleEvent(event) {\n        const cb = this.callback;\n        cb(event, this.elem);\n    }\n    dispose() {\n        this.elem.removeEventListener(this.eventType, this, this.useCapture);\n    }\n}\nclass DomEventMatchListener extends DomEventListener {\n    handleEvent(event) {\n        const elem = _findMatch(event.target, this.elem, this.selector);\n        if (elem) {\n            const cb = this.callback;\n            cb(event, elem);\n        }\n    }\n}\n/**\n * Listen to a DOM event. The `on()` variant takes no `elem` argument, and may be used as an\n * argument to dom() function.\n * @param {DOMElement} elem: DOM Element to listen to.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is `elem`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nfunction onElem(elem, eventType, callback, { useCapture = false } = {}) {\n    return new DomEventListener(elem, eventType, callback, useCapture);\n}\nexports.onElem = onElem;\nfunction on(eventType, callback, { useCapture = false } = {}) {\n    // tslint:disable-next-line:no-unused-expression\n    return (elem) => { new DomEventListener(elem, eventType, callback, useCapture); };\n}\nexports.on = on;\n/**\n * Listen to a DOM event on descendants of the given elem matching the given selector. The\n * `onMatch()` variant takes no `elem` argument, and may be used as an argument to dom().\n * @param {DOMElement} elem: DOM Element to whose descendants to listen.\n * @param {String} selector: CSS selector string to filter elements that trigger this event.\n *    JQuery calls it \"delegated events\" (http://api.jquery.com/on/). The callback will only be\n *    called when the event occurs for an element matching the given selector. If there are\n *    multiple elements matching the selector, the callback is only called for the innermost one.\n * @param {String} eventType: Event type to listen for (e.g. 'click').\n * @param {Function} callback: Callback to call as `callback(event, elem)`, where elem is a\n *    descendent of `elem` which matches `selector`.\n * @param [Boolean] options.useCapture: Add the listener in the capture phase. This should very\n *    rarely be useful (e.g. JQuery doesn't even offer it as an option).\n * @returns {Object} Listener object whose .dispose() method will remove the event listener.\n */\nfunction onMatchElem(elem, selector, eventType, callback, { useCapture = false } = {}) {\n    return new DomEventMatchListener(elem, eventType, callback, useCapture, selector);\n}\nexports.onMatchElem = onMatchElem;\nfunction onMatch(selector, eventType, callback, { useCapture = false } = {}) {\n    // tslint:disable-next-line:no-unused-expression\n    return (elem) => { new DomEventMatchListener(elem, eventType, callback, useCapture, selector); };\n}\nexports.onMatch = onMatch;\n/**\n * Listen to key events (typically 'keydown' or 'keypress'), with specified per-key callbacks.\n * Key names are listed at https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n *\n * Methods onKeyPress() and onKeyDown() are intended to be used as arguments to dom().\n *\n * By default, handled events are stopped from bubbling with stopPropagation() and\n * preventDefault(). If, however, you register a key with a \"$\" suffix (i.e. \"Enter$\" instead of\n * \"Enter\"), then the event is allowed to bubble normally.\n *\n * When this handler is set on an element, we automatically ensure that tabindex attribute is set,\n * to allow this element to receive keyboard events.\n *\n * For example:\n *\n *    dom('input', ...\n *      dom.onKeyDown({\n *        Enter: (e, elem) => console.log(\"Enter pressed\"),\n *        Escape: (e, elem) => console.log(\"Escape pressed\"),\n *        Delete$: (e, elem) => console.log(\"Delete pressed, will bubble\"),\n *      })\n *    )\n */\nfunction onKeyElem(elem, evType, keyHandlers) {\n    if (!(elem.tabIndex >= 0)) { // If tabIndex property is undefined or -1,\n        elem.setAttribute('tabindex', '-1'); // Set tabIndex attribute to make the element focusable.\n    }\n    return onElem(elem, evType, (ev, _elem) => {\n        const plainHandler = keyHandlers[ev.key];\n        const handler = plainHandler || keyHandlers[ev.key + '$'];\n        if (handler) {\n            if (plainHandler) {\n                ev.stopPropagation();\n                ev.preventDefault();\n            }\n            handler(ev, _elem);\n        }\n    });\n}\nexports.onKeyElem = onKeyElem;\nfunction onKeyPress(keyHandlers) {\n    return (elem) => { onKeyElem(elem, 'keypress', keyHandlers); };\n}\nexports.onKeyPress = onKeyPress;\nfunction onKeyDown(keyHandlers) {\n    return (elem) => { onKeyElem(elem, 'keydown', keyHandlers); };\n}\nexports.onKeyDown = onKeyDown;\n//# sourceMappingURL=domevent.js.map","\"use strict\";\n/**\n * emit.js implements an Emitter class which emits events to a list of listeners. Listeners are\n * simply functions to call, and \"emitting an event\" just calls those functions.\n *\n * This is similar to Backbone events, with more focus on efficiency. Both inserting and removing\n * listeners is constant time.\n *\n * To create an emitter:\n *    let emitter = new Emitter();\n *\n * To add a listener:\n *    let listener = fooEmitter.addListener(callback);\n * To remove a listener:\n *    listener.dispose();\n *\n * The only way to remove a listener is to dispose the Listener object returned by addListener().\n * You can often use autoDispose to do this automatically when subscribing in a constructor:\n *    this.autoDispose(fooEmitter.addListener(this.onFoo, this));\n *\n * To emit an event, call emit() with any number of arguments:\n *    emitter.emit(\"hello\", \"world\");\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Listener = exports.Emitter = exports.LLink = void 0;\n// Note about a possible alternative implementation.\n//\n// We could implement the same interface using an array of listeners. Certain issues apply, in\n// particular with removing listeners from inside emit(), and in ensuring that removals are\n// constant time on average. Such an implementation was attempted and timed. The result is that\n// compared to the linked-list implementation here, add/remove combination could be made nearly\n// twice faster (on average), while emit and add/remove/emit are consistently slightly slower.\n//\n// The implementation here was chosen based on those timings, and as the simpler one. For example,\n// on one setup (macbook, node4, 5-listener queue), add+remove take 0.1us, while add+remove+emit\n// take 3.82us. (In array-based implementation with same set up, add+remove is 0.06us, while\n// add+remove+emit is 4.80us.)\n// The private property name to hold next/prev pointers.\nfunction _noop() { }\n/**\n * This is an implementation of a doubly-linked list, with just the minimal functionality we need.\n */\nclass LLink {\n    constructor() {\n        this._next = null;\n        this._prev = null;\n        // This immediate circular reference might be undesirable for GC, but might not matter, and\n        // makes the linked list implementation simpler and faster.\n        this._next = this;\n        this._prev = this;\n    }\n    isDisposed() {\n        return !this._next;\n    }\n    _insertBefore(next, node) {\n        const last = next._prev;\n        last._next = node;\n        next._prev = node;\n        node._prev = last;\n        node._next = next;\n    }\n    _removeNode(node) {\n        if (node._prev) {\n            node._prev._next = node._next;\n            node._next._prev = node._prev;\n        }\n        node._prev = node._next = null;\n    }\n    _disposeList() {\n        let node = this;\n        let next = node._next;\n        while (next !== null) {\n            node._next = node._prev = null;\n            node = next;\n            next = node._next;\n        }\n    }\n}\nexports.LLink = LLink;\nclass Emitter extends LLink {\n    /**\n     * Constructs an Emitter object.\n     */\n    constructor() {\n        super();\n        this._changeCB = _noop;\n        this._changeCBContext = undefined;\n    }\n    /**\n     * Adds a listening callback to the list of functions to call on emit().\n     * @param {Function} callback: Function to call.\n     * @param {Object} optContext: Context for the function.\n     * @returns {Listener} Listener object. Its dispose() method removes the callback from the list.\n     */\n    addListener(callback, optContext) {\n        return new Listener(this, callback, optContext);\n    }\n    /**\n     * Calls all listener callbacks, passing all arguments to each of them.\n     */\n    emit(...args) {\n        Listener.callAll(this._next, this, args);\n    }\n    /**\n     * Sets the single callback that would get called when a listener is added or removed.\n     * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n     *    removed. It's called with a boolean indicating whether this Emitter has any listeners.\n     *    Pass in `null` to unset the callback. Note that it can be called multiple times in a row\n     *    with hasListeners `true`.\n     */\n    setChangeCB(changeCB, optContext) {\n        this._changeCB = changeCB || _noop;\n        this._changeCBContext = optContext;\n    }\n    /**\n     * Helper used by Listener class, but not intended for public usage.\n     */\n    _triggerChangeCB() {\n        this._changeCB.call(this._changeCBContext, this.hasListeners());\n    }\n    /**\n     * Returns whether this Emitter has any listeners.\n     */\n    hasListeners() {\n        return this._next !== this;\n    }\n    /**\n     * Disposes the Emitter. It breaks references between the emitter and all the items, allowing\n     * for better garbage collection. It effectively disposes all current listeners.\n     */\n    dispose() {\n        this._disposeList();\n        this._changeCB = _noop;\n        this._changeCBContext = undefined;\n    }\n}\nexports.Emitter = Emitter;\n/**\n * Listener object wraps a callback added to an Emitter, allowing for O(1) removal when the\n * listener is disposed.\n */\nclass Listener extends LLink {\n    constructor(emitter, callback, context) {\n        super();\n        this.emitter = emitter;\n        this.callback = callback;\n        this.context = context;\n        this._insertBefore(emitter, this);\n        emitter._triggerChangeCB();\n    }\n    static callAll(begin, end, args) {\n        while (begin !== end) {\n            const lis = begin;\n            lis.callback.call(lis.context, ...args);\n            begin = lis._next;\n        }\n    }\n    dispose() {\n        if (this.isDisposed()) {\n            return;\n        }\n        this._removeNode(this);\n        this.emitter._triggerChangeCB();\n    }\n}\nexports.Listener = Listener;\n//# sourceMappingURL=emit.js.map","\"use strict\";\n/**\n * Grain.js observables and computeds are similar to (and mostly inspired by) those in\n * Knockout.js. In fact, they can work together.\n *\n *  import {fromKo} from 'kowrap'\n *\n *  fromKo(koObservable)\n *\n * returns a Grain.js observable that mirrors the passed-in Knockout observable (which may be a\n * computed as well). Similarly,\n *\n *  import {toKo} from 'kowrap';\n *  import * as ko from 'knockout';\n *\n *  toKo(ko, observable)\n *\n * returns a Knockout.js observable that mirrows the passed-in Grain observable or computed. Note\n * that toKo() mus tbe called with the knockout module as an argument. This is to avoid adding\n * knockout as a dependency of grainjs.\n *\n * In both cases, calling fromKo/toKo twice on the same observable will return the same wrapper,\n * and subscriptions and disposal are appropriately set up to make usage seamless. In particular,\n * the returned wrapper should not be disposed; it's tied to the lifetime of the wrapped object.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.setupKoDisposal = exports.toKo = exports.KoWrapObs = exports.fromKo = void 0;\nconst domDispose_1 = require(\"./domDispose\");\nconst observable_1 = require(\"./observable\");\nconst fromKoWrappers = new WeakMap();\nconst toKoWrappers = new WeakMap();\n/**\n * Returns a Grain.js observable which mirrors a Knockout observable.\n *\n * Do not dispose this wrapper, as it is shared by all code using koObs, and its lifetime is tied\n * to the lifetime of koObs. If unused, it consumes minimal resources, and should get garbage\n * collected along with koObs.\n */\nfunction fromKo(koObs) {\n    return fromKoWrappers.get(koObs) || fromKoWrappers.set(koObs, new KoWrapObs(koObs)).get(koObs);\n}\nexports.fromKo = fromKo;\n/**\n * An Observable that wraps a Knockout observable, created via fromKo(). It keeps minimal overhead\n * when unused by only subscribing to the wrapped observable while it itself has subscriptions.\n *\n * This way, when unused, the only reference is from the wrapper to the wrapped object. KoWrapObs\n * should not be disposed; its lifetime is tied to that of the wrapped object.\n */\nclass KoWrapObs extends observable_1.Observable {\n    constructor(_koObs) {\n        super(_koObs.peek());\n        this._koObs = _koObs;\n        this._koSub = null;\n        this.setListenerChangeCB((hasListeners) => {\n            if (!hasListeners) {\n                this._koSub.dispose();\n                this._koSub = null;\n            }\n            else if (!this._koSub) {\n                // TODO this is a little hack, really, BaseObservable should expose a way to set the value\n                // directly by derived classes, i.e. a protected setter.\n                this._value = this._koObs.peek();\n                this._koSub = this._koObs.subscribe((val) => this.setAndTrigger(val));\n            }\n        });\n    }\n    get() { return this._koObs.peek(); }\n    set(value) { observable_1.bundleChanges(() => this._koObs(value)); }\n    dispose() { throw new Error(\"KoWrapObs should not be disposed\"); }\n}\nexports.KoWrapObs = KoWrapObs;\n/**\n * Returns a Knockout observable which mirrors a Grain.js observable.\n */\nfunction toKo(knockout, grainObs) {\n    const prevKoObs = toKoWrappers.get(grainObs);\n    if (prevKoObs) {\n        return prevKoObs;\n    }\n    const newKoObs = knockout.observable(grainObs.get());\n    toKoWrappers.set(grainObs, newKoObs);\n    grainObs.addListener((val) => newKoObs(val));\n    return newKoObs;\n}\nexports.toKo = toKo;\n// Marker for when knockout-disposal integration has already been setup.\nlet koDisposalIsSetup = false;\n/**\n * Set up integration between grainjs and knockout disposal. Knockout does cleanup using\n * ko.removeNode / ko.cleanNode (it also takes care of JQuery cleanup if needed). GrainJS does\n * cleanup using dom.domDispose(). By default these don't know about each other.\n *\n * If you mix the two libraries, however, disposing an element may need to trigger disposers\n * registered by either library.\n *\n * This method ensures that this happens.\n *\n * Note: grainjs disposes text nodes too, but nothing relies on it. When disposal is triggered via\n * knockout, we are forced to rely on knockout's node traversal which ignores text nodes.\n */\nfunction setupKoDisposal(ko) {\n    // Ensure we don't do the setup more than once, or things will get called multiple times.\n    if (koDisposalIsSetup) {\n        return;\n    }\n    koDisposalIsSetup = true;\n    const koDomNodeDisposal = ko.utils.domNodeDisposal;\n    // Knockout by default has an external-data-cleanup func set to cleanup JQuery. Whatever it is\n    // set to, we will continue calling it, and also will call grainjs domDisposeNode.\n    const origKoCleanExternalData = koDomNodeDisposal.cleanExternalData;\n    // The original function called by grainjs to clean nodes recursively. We'll override it.\n    const origGrainDisposeRecursive = domDispose_1.domDisposeHooks.disposeRecursive;\n    // New function called by knockout to do extra cleanup. Now calls grainjs single-node cleanup.\n    // (In knockout, we can only override single-node cleanup.)\n    function newKoCleanExternalData(node) {\n        origKoCleanExternalData(node);\n        domDispose_1.domDisposeHooks.disposeNode(node);\n    }\n    // Function called by grainjs to clean nodes recursively. We override the recursive cleanup\n    // function to call the recursive knockout cleanup (letting knockout do the dom traversal it\n    // normally does).\n    function newGrainDisposeRecursive(node) {\n        origGrainDisposeRecursive(node);\n        // While doing knockout cleanup, do NOT have it call grainjs cleanup too, as that would cause\n        // multiple unnecessary traversals of DOM.\n        koDomNodeDisposal.cleanExternalData = origKoCleanExternalData;\n        try {\n            ko.cleanNode(node);\n        }\n        finally {\n            koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;\n        }\n    }\n    // Use knockout and grainjs hooks to actually set the new cleanup functions.\n    koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;\n    domDispose_1.domDisposeHooks.disposeRecursive = newGrainDisposeRecursive;\n}\nexports.setupKoDisposal = setupKoDisposal;\n//# sourceMappingURL=kowrap.js.map","\"use strict\";\n/**\n * ObsArray extends a plain Observable to allow for more efficient observation of array changes.\n *\n * As for any array-valued Observable, when the contents of the observed array changes, the\n * listeners get called with new and previous values which are the same array. For simple changes,\n * such as those made with .push() and .splice() methods, ObsArray allows for more efficient\n * handling of the change by calling listeners with splice info in the third argument.\n *\n * This module also provides computedArray(), which allows mapping each item of an ObsArray\n * through a function, passing through splice info for efficient handling of small changes. It\n * also allows mapping an observable or a computed whose value is an ObsArray.\n *\n * There is no need or benefit in using computedArray() if you have a computed() that returns a\n * plain array. It is specifically for the case when you want to preserve the efficiency of\n * ObsArray when you map its values.\n *\n * Both ObsArray and ComputedArray may be used with disposable elements as their owners. E.g.\n *\n *    const arr = obsArray<D>();\n *    arr.push(D.create(arr, \"x\"), D.create(arr, \"y\"));\n *    arr.pop();      // Element \"y\" gets disposed.\n *    arr.dispose();  // Element \"x\" gets disposed.\n *\n *    const values = obsArray<string>();\n *    const compArr = computedArray<D>(values, (val, i, compArr) => D.create(compArr, val));\n *    values.push(\"foo\", \"bar\");      // D(\"foo\") and D(\"bar\") get created\n *    values.pop();                   // D(\"bar\") gets disposed.\n *    compArr.dispose();              // D(\"foo\") gets disposed.\n *\n * Note that only the pattern above works: obsArray (or compArray) may only be used to take\n * ownership of those disposables that are added to it as array elements.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LiveIndex = exports.makeLiveIndex = exports.computedArray = exports.ComputedArray = exports.obsArray = exports.MutableObsArray = exports.ObsArray = void 0;\nconst dispose_1 = require(\"./dispose\");\nconst observable_1 = require(\"./observable\");\nconst subscribe_1 = require(\"./subscribe\");\n/**\n * ObsArray<T> is essentially an array-valued observable. The main difference is that it may be\n * used as an owner for disposable array elements.\n */\nclass ObsArray extends observable_1.BaseObservable {\n    constructor() {\n        super(...arguments);\n        this._ownedItems = undefined;\n    }\n    addListener(callback, optContext) {\n        return super.addListener(callback, optContext);\n    }\n    autoDispose(value) {\n        if (!this._ownedItems) {\n            this._ownedItems = new Set();\n        }\n        this._ownedItems.add(value);\n        return value;\n    }\n    dispose() {\n        if (this._ownedItems) {\n            for (const item of this.get()) {\n                if (this._ownedItems.delete(item)) {\n                    item.dispose();\n                }\n            }\n            this._ownedItems = undefined;\n        }\n        super.dispose();\n    }\n    _setWithSplice(value, splice) {\n        return this._setWithArg(value, splice);\n    }\n    _disposeOwned(splice) {\n        if (!this._ownedItems) {\n            return;\n        }\n        if (splice) {\n            for (const item of splice.deleted) {\n                if (this._ownedItems.delete(item)) {\n                    item.dispose();\n                }\n            }\n        }\n        else {\n            const oldOwnedItems = this._ownedItems;\n            // Rebuild the _ownedItems array to have only the current items that were owned from before.\n            this._ownedItems = new Set();\n            for (const item of this.get()) {\n                if (oldOwnedItems.delete(item)) {\n                    this._ownedItems.add(item);\n                }\n            }\n            // After removing current items, dispose any remaining owned items.\n            for (const item of oldOwnedItems) {\n                item.dispose();\n            }\n        }\n    }\n}\nexports.ObsArray = ObsArray;\n/**\n * MutableObsArray<T> adds array-like mutation methods which emit events with splice info, to\n * allow more efficient processing of such changes. It is created with obsArray<T>().\n */\nclass MutableObsArray extends ObsArray {\n    push(...args) {\n        const value = this.get();\n        const start = value.length;\n        const newLen = value.push(...args);\n        this._setWithSplice(value, { start, numAdded: args.length, deleted: [] });\n        return newLen;\n    }\n    pop() {\n        const value = this.get();\n        if (value.length === 0) {\n            return undefined;\n        }\n        const ret = value.pop();\n        this._setWithSplice(value, { start: value.length, numAdded: 0, deleted: [ret] });\n        return ret;\n    }\n    unshift(...args) {\n        const value = this.get();\n        const newLen = value.unshift(...args);\n        this._setWithSplice(value, { start: 0, numAdded: args.length, deleted: [] });\n        return newLen;\n    }\n    shift() {\n        const value = this.get();\n        if (value.length === 0) {\n            return undefined;\n        }\n        const ret = value.shift();\n        this._setWithSplice(value, { start: 0, numAdded: 0, deleted: [ret] });\n        return ret;\n    }\n    splice(start, deleteCount = Infinity, ...newValues) {\n        const value = this.get();\n        const len = value.length;\n        start = Math.min(len, Math.max(0, start < 0 ? len + start : start));\n        const deleted = value.splice(start, deleteCount, ...newValues);\n        this._setWithSplice(value, { start, numAdded: newValues.length, deleted });\n        return deleted;\n    }\n}\nexports.MutableObsArray = MutableObsArray;\n/**\n * Creates a new MutableObsArray with an optional initial value, defaulting to the empty array.\n * It is essentially the same as observable<T[]>, but with array-like mutation methods.\n */\nfunction obsArray(value = []) {\n    return new MutableObsArray(value);\n}\nexports.obsArray = obsArray;\n/**\n * Returns true if val is an array-valued observable.\n */\nfunction isObsArray(val) {\n    return Array.isArray(val.get());\n}\n/**\n * See computedArray() below for documentation.\n */\nclass ComputedArray extends ObsArray {\n    constructor(obsArr, _mapper) {\n        super([]);\n        this._mapper = _mapper;\n        this._sub = isObsArray(obsArr) ?\n            subscribe_1.subscribe(obsArr, (use) => this._syncMap(obsArr)) :\n            subscribe_1.subscribe(obsArr, (use, obsArrayValue) => { use(obsArrayValue); return this._syncMap(obsArrayValue); });\n    }\n    dispose() {\n        this._unsync();\n        this._sub.dispose();\n        super.dispose();\n    }\n    _syncMap(obsArr) {\n        if (this._source !== obsArr) {\n            this._unsync();\n            this._listener = obsArr.addListener(this._recordChange, this);\n            this._source = obsArr;\n            this._rebuild(obsArr);\n        }\n        else if (this._lastSplice) {\n            // If we are syncing to the same array as before and recorded a single splice, apply it now.\n            this._applySplice(obsArr, this._lastSplice);\n        }\n        else {\n            // If the full array changed or we had multiple splices, give up and rebuild.\n            this._rebuild(obsArr);\n        }\n        this._lastSplice = undefined;\n    }\n    _unsync() {\n        if (this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n            this._source = undefined;\n        }\n    }\n    _rebuild(obsArr) {\n        this.set(obsArr.get().map((item, i) => this._mapper.call(undefined, item, i, this)));\n    }\n    _applySplice(obsArr, change) {\n        const sourceArray = obsArr.get();\n        const newItems = [];\n        for (let i = change.start, n = 0; n < change.numAdded; i++, n++) {\n            newItems.push(this._mapper.call(undefined, sourceArray[i], i, this));\n        }\n        const items = this.get();\n        const deleted = items.splice(change.start, change.deleted.length, ...newItems);\n        this._setWithSplice(items, { start: change.start, numAdded: newItems.length, deleted });\n    }\n    _recordChange(newItems, oldItems, change) {\n        // We don't attempt to handle efficiency multiple splices (it's quite hard in general, and\n        // even harder to know that it's more efficient than rebuilding), so if _lastSplice is set, we\n        // set it to a marker to mark the array for rebuilding.\n        if (change && this._lastSplice === undefined) {\n            this._lastSplice = change;\n        }\n        else {\n            this._lastSplice = false; // This is a marker that a full rebuild is needed.\n        }\n    }\n}\nexports.ComputedArray = ComputedArray;\n/**\n * Returns an ObsArray that maps all elements of the passed-in ObsArray through a mapper function.\n * Also accepts an observable (e.g. a computed) whose value is an ObsArray. Usage:\n *\n *    computedArray(obsArray, mapper)\n *\n * The result is entirely analogous to:\n *\n *     computed((use) => use(obsArray).map(mapper))       // for ObsArray\n *     computed((use) => use(use(obsArray)).map(mapper))  // for Observable<ObsArray>\n *\n * The benefit of computedArray() is that a small change to the source array (e.g. one item\n * added or removed), causes a small change to the mapped array, rather than a full rebuild.\n *\n * This is useful with an ObsArray or with an observable whose value is an ObsArray, and also\n * when the computed array owns its disposable items.\n *\n * Note that the mapper function is called with (item, index, array) as for a standard\n * array.map(), but that the index is only accurate at the time of the call, and will stop\n * reflecting the true index if more items are inserted into the array later.\n */\nfunction computedArray(obsArr, mapper) {\n    return new ComputedArray(obsArr, mapper);\n}\nexports.computedArray = computedArray;\n/**\n * Returns a new observable representing an index into this array. It can be read and written, and\n * its value is clamped to be a valid index. The index is only null if the array is empty.\n *\n * As the array changes, the index is adjusted to continue pointing to the same element. If the\n * pointed element is deleted, the index is adjusted to after the deletion point.\n *\n * The returned observable has an additional .setLive(bool) method. While set to false, the\n * observable will not be adjusted as the array changes, except to keep it valid.\n */\nfunction makeLiveIndex(owner, obsArr, initialIndex = 0) {\n    return dispose_1.setDisposeOwner(owner, new LiveIndex(obsArr, initialIndex));\n}\nexports.makeLiveIndex = makeLiveIndex;\nclass LiveIndex extends observable_1.Observable {\n    constructor(_obsArray, initialIndex = 0) {\n        super(null);\n        this._obsArray = _obsArray;\n        this._isLive = true;\n        this.set(initialIndex);\n        this._listener = _obsArray.addListener(this._onArrayChange, this);\n    }\n    set(index) {\n        // Clamp to [0, len) range of the observable array.\n        const len = this._obsArray.get().length;\n        super.set(len === 0 ? null : Math.max(0, Math.min(len - 1, index || 0)));\n    }\n    // Note that this feature comes from a rather obscure need, and it would be better if something\n    // similar were possible without making it an explicit feature.\n    setLive(value) {\n        this._isLive = value;\n    }\n    dispose() {\n        this._listener.dispose();\n        super.dispose();\n    }\n    _onArrayChange(newItems, oldItems, change) {\n        const idx = this.get();\n        this.set(idx === null || !change ? 0 :\n            // Adjust the index if it was beyond the deleted region.\n            this._isLive && idx >= change.start + change.deleted.length ? idx + change.numAdded - change.deleted.length :\n                // Adjust the index if it was inside the deleted region (and not replaced).\n                this._isLive && idx >= change.start + change.numAdded ? change.start + change.numAdded :\n                    idx);\n    }\n}\nexports.LiveIndex = LiveIndex;\n//# sourceMappingURL=obsArray.js.map","\"use strict\";\n/**\n * observable.js implements an observable value, which lets other code subscribe to changes.\n *\n * E.g.\n *  let o = observable(17);\n *  o.get();          // 17\n *  o.addListener(foo);\n *  o.set(\"asdf\");    // foo(\"asdf\", 17) gets called.\n *  o.get();          // \"asdf\"\n *\n * To subscribe to changes, use obs.addListener(callback, context). The callback will get called\n * with (newValue, oldValue) as arguments.\n *\n * When you use observables within the body of a computed(), you can automatically create\n * subscriptions to them with the use(obs) function. E.g.\n *    let obs3 = computed(use => use(obs1) + use(obs2));\n * creates a computed observable `obs3` which is subscribed to changes to `obs1` and `obs2`.\n *\n * Note that unlike with knockout, use(obs) method requires an explicit `use` function, which is\n * always passed to a computed's read() callback for this purpose. This makes it explicit when a\n * dependency is created, and which observables the dependency connects.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.obsHolder = exports.observable = exports.Observable = exports.BaseObservable = exports.bundleChanges = void 0;\nconst _computed_queue_1 = require(\"./_computed_queue\");\nconst dispose_1 = require(\"./dispose\");\nconst emit_1 = require(\"./emit\");\nvar _computed_queue_2 = require(\"./_computed_queue\");\nObject.defineProperty(exports, \"bundleChanges\", { enumerable: true, get: function () { return _computed_queue_2.bundleChanges; } });\nclass BaseObservable {\n    /**\n     * Internal constructor for an Observable. You should use observable() function instead.\n     */\n    constructor(value) {\n        this._onChange = new emit_1.Emitter();\n        this._value = value;\n    }\n    /**\n     * Returns the value of the observable. It is fast and does not create a subscription.\n     * (It is similar to knockout's peek()).\n     * @returns {Object} The current value of the observable.\n     */\n    get() { return this._value; }\n    /**\n     * Sets the value of the observable. If the value differs from the previously set one, then\n     * listeners to this observable will get called with (newValue, oldValue) as arguments.\n     * @param {Object} value: The new value to set.\n     */\n    set(value) {\n        if (value !== this._value) {\n            this.setAndTrigger(value);\n        }\n    }\n    /**\n     * Sets the value of the observable AND calls listeners even if the value is unchanged.\n     */\n    setAndTrigger(value) {\n        const prev = this._value;\n        this._value = value;\n        this._onChange.emit(value, prev);\n        this._disposeOwned();\n        _computed_queue_1.compute();\n    }\n    /**\n     * Adds a callback to listen to changes in the observable.\n     * @param {Function} callback: Function, called on changes with (newValue, oldValue) arguments.\n     * @param {Object} optContext: Context for the function.\n     * @returns {Listener} Listener object. Its dispose() method removes the callback.\n     */\n    addListener(callback, optContext) {\n        return this._onChange.addListener(callback, optContext);\n    }\n    /**\n     * Returns whether this observable has any listeners.\n     */\n    hasListeners() {\n        return this._onChange.hasListeners();\n    }\n    /**\n     * Sets a single callback to be called when a listener is added or removed. It overwrites any\n     * previously-set such callback.\n     * @param {Function} changeCB(hasListeners): Function to call after a listener is added or\n     *    removed. It's called with a boolean indicating whether this observable has any listeners.\n     *    Pass in `null` to unset the callback. Note that it can be called multiple times in a row\n     *    with hasListeners `true`.\n     */\n    setListenerChangeCB(changeCB, optContext) {\n        this._onChange.setChangeCB(changeCB, optContext);\n    }\n    /**\n     * Used by subscriptions to keep track of dependencies. An observable that has dependnecies,\n     * such as a computed observable, would override this method.\n     */\n    _getDepItem() {\n        return null;\n    }\n    /**\n     * Disposes the observable.\n     */\n    dispose() {\n        this._disposeOwned();\n        this._onChange.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Returns whether this observable is disposed.\n     */\n    isDisposed() {\n        return this._onChange.isDisposed();\n    }\n    _disposeOwned(arg) { }\n    /**\n     * Allow derived classes to emit change events with an additional third argument describing the\n     * change. It always emits the event without checking for value equality.\n     */\n    _setWithArg(value, arg) {\n        const prev = this._value;\n        this._value = value;\n        this._onChange.emit(value, prev, arg);\n        this._disposeOwned(arg);\n        _computed_queue_1.compute();\n    }\n}\nexports.BaseObservable = BaseObservable;\nclass Observable extends BaseObservable {\n    constructor() {\n        super(...arguments);\n        this._owned = undefined;\n    }\n    // See module-level holder() function below for documentation.\n    static holder(value) {\n        const obs = new Observable(value);\n        obs._owned = value;\n        return obs;\n    }\n    /**\n     * Creates a new Observable with the given initial value, and owned by owner.\n     */\n    static create(owner, value) {\n        return dispose_1.setDisposeOwner(owner, new Observable(value));\n    }\n    /**\n     * The use an observable for a disposable object, use it a DisposableOwner:\n     *\n     *    D.create(obs, ...args)                      // Preferred\n     *    obs.autoDispose(D.create(null, ...args))    // Equivalent\n     *\n     * Either of these usages will set the observable to the newly created value. The observable\n     * will dispose the owned value when it's set to another value, or when it itself is disposed.\n     */\n    autoDispose(value) {\n        this.setAndTrigger(value);\n        this._owned = value;\n        return value;\n    }\n    _disposeOwned() {\n        if (this._owned) {\n            this._owned.dispose();\n            this._owned = undefined;\n        }\n    }\n}\nexports.Observable = Observable;\n/**\n * Creates a new Observable with the initial value of optValue if given or undefined if omitted.\n * @param {Object} optValue: The initial value to set.\n * @returns {Observable} The newly created observable.\n */\nfunction observable(value) {\n    return new Observable(value);\n}\nexports.observable = observable;\n/**\n * Creates a new Observable with an initial disposable value owned by this observable, e.g.\n *\n *    const obs = obsHolder<D>(D.create(null, ...args));\n *\n * This is needed because using simply observable<D>(value) would not cause the observable to take\n * ownership of value (i.e. to dispose it later). This function is a less hacky equivalent to:\n *\n *    const obs = observable<D>(null as any);\n *    D.create(obs, ...args);\n *\n * To allow nulls, use observable<D|null>(null); then the obsHolder() constructor is not needed.\n */\nfunction obsHolder(value) {\n    return Observable.holder(value);\n}\nexports.obsHolder = obsHolder;\n//# sourceMappingURL=observable.js.map","\"use strict\";\n/**\n * pureComputed.js implements a variant of computed() suitable for use with a pure read function\n * (free of side-effects). A pureComputed is only subscribed to its dependencies when something is\n * subscribed to it. At other times, it is not subscribed to anything, and calls to `get()` will\n * recompute its value each time by calling its read() function.\n *\n * Its syntax and usage are otherwise exactly as for a computed.\n *\n * In addition to being cheaper when unused, a pureComputed() also avoids leaking memory when\n * unused (since it's not registered with dependencies), so it is not necessary to dispose it.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pureComputed = exports.PureComputed = void 0;\nconst observable_1 = require(\"./observable\");\nconst subscribe_1 = require(\"./subscribe\");\nfunction _noWrite() {\n    throw new Error(\"Can't write to non-writable pureComputed\");\n}\nfunction _useFunc(obs) {\n    return ('get' in obs) ? obs.get() : obs.peek();\n}\n// Constant empty array, which we use to avoid allocating new read-only empty arrays.\nconst emptyArray = [];\nclass PureComputed extends observable_1.Observable {\n    /**\n     * Internal constructor for a PureComputed. You should use pureComputed() function instead.\n     */\n    constructor(callback, dependencies) {\n        // At initialization we force an undefined value even though it's not of type T: it's not\n        // actually used as get() is overridden.\n        super(undefined);\n        this._callback = callback;\n        this._write = _noWrite;\n        this._dependencies = dependencies.length > 0 ? dependencies : emptyArray;\n        this._sub = null;\n        this._inCall = false;\n        this.setListenerChangeCB(this._onListenerChange, this);\n    }\n    _getDepItem() {\n        this._activate();\n        return this._sub._getDepItem();\n    }\n    get() {\n        if (!this._sub && !this._inCall) {\n            // _inCall member prevents infinite recursion.\n            this._inCall = true;\n            try {\n                const readArgs = [_useFunc];\n                // Note that this attempts to optimize for speed.\n                for (let i = 0, len = this._dependencies.length; i < len; i++) {\n                    readArgs[i + 1] = this._dependencies[i].get();\n                }\n                super.set(this._callback.apply(undefined, readArgs));\n            }\n            finally {\n                this._inCall = false;\n            }\n        }\n        return super.get();\n    }\n    /**\n     * \"Sets\" the value of the pure computed by calling the write() callback if one was provided in\n     * the constructor. Throws an error if there was no such callback (not a \"writable\" computed).\n     * @param {Object} value: The value to pass to the write() callback.\n     */\n    set(value) { this._write(value); }\n    /**\n     * Set callback to call when this.set(value) is called, to make it a writable computed. If not\n     * set, attempting to write to this computed will throw an exception.\n     */\n    onWrite(writeFunc) {\n        this._write = writeFunc;\n        return this;\n    }\n    /**\n     * Disposes the pureComputed, unsubscribing it from all observables it depends on.\n     */\n    dispose() {\n        if (this._sub) {\n            this._sub.dispose();\n        }\n        // Truthy value for _sub prevents some errors after disposal, by avoiding activation or\n        // _directRead calls.\n        this._sub = true;\n        super.dispose();\n    }\n    _activate() {\n        if (!this._sub) {\n            this._sub = new subscribe_1.Subscription(this._read.bind(this), this._dependencies);\n        }\n    }\n    _onListenerChange(hasListeners) {\n        if (hasListeners) {\n            this._activate();\n        }\n        else if (this._sub) {\n            this._sub.dispose();\n            this._sub = null;\n        }\n    }\n    _read(use, ...args) {\n        super.set(this._callback(use, ...args));\n    }\n}\nexports.PureComputed = PureComputed;\n/**\n * Creates and returns a new PureComputed. The interface is identical to that of a Computed.\n */\nfunction pureComputed(...args) {\n    const readCb = args.pop();\n    // The cast helps ensure that Observable is compatible with ISubscribable abstraction that we use.\n    return new PureComputed(readCb, args);\n}\nexports.pureComputed = pureComputed;\n//# sourceMappingURL=pureComputed.js.map","\"use strict\";\n/**\n * In-code styling for DOM components, inspired by Reacts Styled Components.\n *\n * Usage:\n *    const title = styled('h1', `\n *      font-size: 1.5em;\n *      text-align: center;\n *      color: palevioletred;\n *    `);\n *\n *    const wrapper = styled('section', `\n *      padding: 4em;\n *      background: papayawhip;\n *    `);\n *\n *    wrapper(title('Hello world'))\n *\n * This generates class names for title and wrapper, adds the styles to the document on first use,\n * and the result is equivalent to:\n *\n *    dom(`section.${wrapper.className}`, dom(`h1.${title.className}`, 'Hello world'));\n *\n * Calls to styled() should happen at the top level, at import time, in order to register all\n * styles upfront. Actual work happens the first time a style is needed to create an element.\n * Calling styled() elsewhere than at top level is wasteful and bad for performance.\n *\n * You may create a style that modifies an existing styled() or other component, e.g.\n *\n *    const title2 = styled(title, `font-size: 1rem; color: red;`);\n *\n * Calling title2('Foo') becomes equivalent to dom(`h1.${title.className}.${title2.className}`).\n *\n * Styles may incorporate other related styles by nesting them under the main one as follows:\n *\n *     const myButton = styled('button', `\n *       border-radius: 0.5rem;\n *       border: 1px solid grey;\n *       font-size: 1rem;\n *\n *       &:active {\n *         background: lightblue;\n *       }\n *       &-small {\n *         font-size: 0.6rem;\n *       }\n *     `);\n *\n * In nested styles, ampersand (&) gets replaced with the generated .className of the main element.\n *\n * The resulting styled component provides a .cls() helper to simplify using prefixed classes. It\n * behaves as dom.cls(), but prefixes the class names with the generated className of the main\n * element. E.g. for the example above,\n *\n *      myButton(myButton.cls('-small'), 'Test')\n *\n * creates a button with both the myButton style above, and the style specified under \"&-small\".\n *\n * Animations with @keyframes may be created with a unique name by using the keyframes() helper:\n *\n *    const rotate360 = keyframes(`\n *      from { transform: rotate(0deg); }\n *      to { transform: rotate(360deg); }\n *    `);\n *\n *    const Rotate = styled('div', `\n *      display: inline-block;\n *      animation: ${rotate360} 2s linear infinite;\n *    `);\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.keyframes = exports.styled = void 0;\n// Use the browser globals in a way that allows replacing them with mocks in tests.\nconst browserGlobals_1 = require(\"./browserGlobals\");\nconst domImpl_1 = require(\"./domImpl\");\nconst domMethods_1 = require(\"./domMethods\");\nfunction styled(creator, styles) {\n    // Note that we intentionally minimize the work done when styled() is called; it's better to do\n    // any needed work on first use. That's when we will actually build the css rules.\n    const style = new StylePiece(styles);\n    // Creator function reflects the input, with only the addition of style.use() at the end. Note\n    // that it needs to be at the end because creator() might take special initial arguments.\n    const newCreator = (typeof creator === 'string') ?\n        (...args) => style.addToElem(domImpl_1.dom(creator, ...args)) :\n        (...args) => style.addToElem(creator(...args));\n    return Object.assign(newCreator, {\n        className: style.className,\n        cls: domMethods_1.clsPrefix.bind(null, style.className),\n    });\n}\nexports.styled = styled;\n// Keyframes produces simply a string with the generated name. Note that these does not support\n// nesting or ampersand (&) handling, since these would be difficult and are entirely unneeded.\nfunction keyframes(styles) {\n    return (new KeyframePiece(styles)).className;\n}\nexports.keyframes = keyframes;\nfunction createCssRules(className, styles) {\n    // The first time we encounter a nested section, we know which are the \"main\" rules, and can\n    // wrap them appropriately.\n    const nestedStart = styles.search(/[^;]*\\{/);\n    const mainRules = nestedStart < 0 ? styles : styles.slice(0, nestedStart);\n    const nestedRules = nestedStart < 0 ? \"\" : styles.slice(nestedStart);\n    // At the end, replace all occurrences of & with \".className\".\n    return `& {${mainRules}\\n}\\n${nestedRules}`.replace(/&/g, className);\n}\n// Used by getNextStyleNum when running without a global window object (e.g. in tests).\nconst _global = {};\n// Keep the counter for next class attached to the global window object rather than be a library\n// global. This way if by some chance multiple instance of grainjs are loaded into the page, it\n// still works without overwriting class names (which would be extremely confusing).\nfunction getNextStyleNum() {\n    const g = browserGlobals_1.G.window || _global;\n    return g._grainNextStyleNum = (g._grainNextStyleNum || 0) + 1;\n}\nclass StylePiece {\n    constructor(_styles) {\n        this._styles = _styles;\n        this._mounted = false;\n        this.className = StylePiece._nextClassName();\n        StylePiece._unmounted.add(this);\n    }\n    // Generate a new css class name. The suffix ensures that names like \"&2\" can't cause a conflict.\n    static _nextClassName() { return `_grain${getNextStyleNum()}_`; }\n    // Mount all unmounted StylePieces, and clear the _unmounted map.\n    static _mountAll() {\n        const sheet = Array.from(this._unmounted, (p) => p._createRules()).join(\"\\n\\n\");\n        browserGlobals_1.G.document.head.appendChild(domImpl_1.dom('style', sheet));\n        for (const piece of this._unmounted) {\n            piece._mounted = true;\n        }\n        this._unmounted.clear();\n    }\n    addToElem(elem) {\n        if (!this._mounted) {\n            StylePiece._mountAll();\n        }\n        elem.classList.add(this.className);\n        return elem;\n    }\n    _createRules() {\n        return createCssRules('.' + this.className, this._styles);\n    }\n}\n// Set of all StylePieces created but not yet mounted.\nStylePiece._unmounted = new Set();\nclass KeyframePiece extends StylePiece {\n    _createRules() {\n        return `@keyframes ${this.className} {${this._styles}}`;\n    }\n}\n//# sourceMappingURL=styled.js.map","\"use strict\";\n/**\n * subscribe.js implements subscriptions to several observables at once.\n *\n * E.g. if we have some existing observables (which may be instances of `computed`),\n * we can subscribe to them explicitly:\n *    let obs1 = observable(5), obs2 = observable(12);\n *    subscribe(obs1, obs2, (use, v1, v2) => console.log(v1, v2));\n *\n * or implicitly by using `use(obs)` function, which allows dynamic subscriptions:\n *    subscribe(use => console.log(use(obs1), use(obs2)));\n *\n * In either case, if obs1 or obs2 is changed, the callbacks will get called automatically.\n *\n * Creating a subscription allows any number of dependencies to be specified explicitly, and their\n * values will be passed to the callback(). These may be combined with automatic dependencies\n * detected using use(). Note that constructor dependencies have less overhead.\n *\n *    subscribe(...deps, ((use, ...depValues) => READ_CALLBACK));\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subscribe = exports.Subscription = void 0;\nconst _computed_queue_1 = require(\"./_computed_queue\");\nconst kowrap_1 = require(\"./kowrap\");\n// Constant empty array, which we use to avoid allocating new read-only empty arrays.\nconst emptyArray = [];\nclass Subscription {\n    /**\n     * Internal constructor for a Subscription. You should use subscribe() function instead.\n     * The last owner argument is used by computed() to make itself available as the .owner property\n     * of the 'use' function that gets passed to the callback.\n     */\n    constructor(callback, dependencies, owner) {\n        this._depItem = new _computed_queue_1.DepItem(this._evaluate, this);\n        this._dependencies = dependencies.length > 0 ? dependencies : emptyArray;\n        this._depListeners = dependencies.length > 0 ? dependencies.map((obs) => this._subscribeTo(obs)) : emptyArray;\n        this._dynDeps = new Map(); // Maps dependent observable to its Listener object.\n        this._callback = callback;\n        this._useFunc = this._useDependency.bind(this);\n        if (owner) {\n            this._useFunc.owner = owner;\n        }\n        this._evaluate();\n    }\n    /**\n     * Disposes the computed, unsubscribing it from all observables it depends on.\n     */\n    dispose() {\n        this._callback = null;\n        for (const lis of this._depListeners) {\n            lis.dispose();\n        }\n        for (const lis of this._dynDeps.values()) {\n            lis.dispose();\n        }\n    }\n    /**\n     * For use by computed(): returns this subscription's hook into the _computed_queue.\n     */\n    _getDepItem() { return this._depItem; }\n    /**\n     * @private\n     * Gets called when the callback calls `use(obs)` for an observable. It creates a\n     * subscription to `obs` if one doesn't yet exist.\n     * @param {Observable} obs: The observable being used as a dependency.\n     */\n    _useDependency(_obs) {\n        const obs = ('_getDepItem' in _obs) ? _obs : kowrap_1.fromKo(_obs);\n        let listener = this._dynDeps.get(obs);\n        if (!listener) {\n            listener = this._subscribeTo(obs);\n            this._dynDeps.set(obs, listener);\n        }\n        listener._inUse = true;\n        this._depItem.useDep(obs._getDepItem());\n        return obs.get();\n    }\n    /**\n     * @private\n     * Calls the callback() with appropriate args, and updates subscriptions when it is done.\n     * I.e. adds dynamic subscriptions created via `use(obs)`, and disposes those no longer used.\n     */\n    _evaluate() {\n        if (this._callback === null) {\n            return;\n        } // Means this Subscription has been disposed.\n        try {\n            // Note that this is faster than using .map().\n            const readArgs = [this._useFunc];\n            for (let i = 0, len = this._dependencies.length; i < len; i++) {\n                readArgs[i + 1] = this._dependencies[i].get();\n                this._depItem.useDep(this._dependencies[i]._getDepItem());\n            }\n            return this._callback.apply(undefined, readArgs);\n        }\n        finally {\n            this._dynDeps.forEach((listener, obs) => {\n                if (listener._inUse) {\n                    listener._inUse = false;\n                }\n                else {\n                    this._dynDeps.delete(obs);\n                    listener.dispose();\n                }\n            });\n        }\n    }\n    /**\n     * @private\n     * Subscribes this computed to another observable that it depends on.\n     * @param {Observable} obs: The observable to subscribe to.\n     * @returns {Listener} Listener object.\n     */\n    _subscribeTo(_obs) {\n        const obs = ('_getDepItem' in _obs) ? _obs : kowrap_1.fromKo(_obs);\n        return obs.addListener(this._enqueue, this);\n    }\n    /**\n     * @private\n     * Adds this item to the recompute queue.\n     */\n    _enqueue() {\n        this._depItem.enqueue();\n    }\n}\nexports.Subscription = Subscription;\n/**\n * Creates a new Subscription.\n * @param {Observable} ...observables: The initial params, of which there may be zero or more, are\n *    observables on which this computed depends. When any of them change, the callback()\n *    will be called with the values of these observables as arguments.\n * @param {Function} callback: will be called with arguments (use, ...values), i.e. the\n *    `use` function and values for all of the ...observables that precede this argument.\n *    This callback is called immediately, and whenever any dependency changes.\n * @returns {Subscription} The new subscription which may be disposed to unsubscribe.\n */\nfunction subscribe(...args) {\n    const cb = args.pop();\n    // The cast helps ensure that Observable is compatible with ISubscribable abstraction that we use.\n    return new Subscription(cb, args);\n}\nexports.subscribe = subscribe;\n//# sourceMappingURL=subscribe.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bindBU = exports.bindUB = exports.bindB = void 0;\n/**\n * Returns f such that f() calls func(...boundArgs), i.e. optimizes `() => func(...boundArgs)`.\n * It is faster on node6 by 57-92%.\n */\nfunction bindB(func, b) {\n    switch (b.length) {\n        case 0: return () => func();\n        case 1: return () => func(b[0]);\n        case 2: return () => func(b[0], b[1]);\n        case 3: return () => func(b[0], b[1], b[2]);\n        case 4: return () => func(b[0], b[1], b[2], b[3]);\n        case 5: return () => func(b[0], b[1], b[2], b[3], b[4]);\n        case 6: return () => func(b[0], b[1], b[2], b[3], b[4], b[5]);\n        case 7: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n        case 8: return () => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n        default: return () => func.apply(undefined, b);\n    }\n}\nexports.bindB = bindB;\n/**\n * Returns f such that f(unboundArg) calls func(unboundArg, ...boundArgs).\n * I.e. optimizes `(arg) => func(arg, ...boundArgs)`.\n * It is faster on node6 by 0-92%.\n */\nfunction bindUB(func, b) {\n    switch (b.length) {\n        case 0: return (arg) => func(arg);\n        case 1: return (arg) => func(arg, b[0]);\n        case 2: return (arg) => func(arg, b[0], b[1]);\n        case 3: return (arg) => func(arg, b[0], b[1], b[2]);\n        case 4: return (arg) => func(arg, b[0], b[1], b[2], b[3]);\n        case 5: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4]);\n        case 6: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5]);\n        case 7: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6]);\n        case 8: return (arg) => func(arg, b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7]);\n        default: return (arg) => func(arg, ...b);\n    }\n}\nexports.bindUB = bindUB;\n/**\n * Returns f such that f(unboundArg) calls func(...boundArgs, unboundArg).\n * I.e. optimizes `(arg) => func(...boundArgs, arg)`.\n * It is faster on node6 by 0-92%.\n */\nfunction bindBU(func, b) {\n    switch (b.length) {\n        case 0: return (arg) => func(arg);\n        case 1: return (arg) => func(b[0], arg);\n        case 2: return (arg) => func(b[0], b[1], arg);\n        case 3: return (arg) => func(b[0], b[1], b[2], arg);\n        case 4: return (arg) => func(b[0], b[1], b[2], b[3], arg);\n        case 5: return (arg) => func(b[0], b[1], b[2], b[3], b[4], arg);\n        case 6: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], arg);\n        case 7: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], arg);\n        case 8: return (arg) => func(b[0], b[1], b[2], b[3], b[4], b[5], b[6], b[7], arg);\n        default: return (arg) => func(...b, arg);\n    }\n}\nexports.bindBU = bindBU;\n//# sourceMappingURL=util.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.input = void 0;\n/**\n * General INPUT widget.\n */\nconst index_1 = require(\"../../index\");\n/**\n * Creates a input element tied to the given observable. The required options argument allows\n * controlling the behavior, see IInputOptions for details.\n *\n * This is intended for string input elements, with \"type\" such as text, email, url, password,\n * number, tel.\n *\n * Note that every change to the observable will affect the input element, but not every change to\n * the input element will affect the observable. Specifically, unless {onInput: true} is set, the\n * visible content may differ from the observable until the element loses focus or Enter is hit.\n *\n * Example usage:\n *    input(obs, {}, {type: 'text', placeholder: 'Your name...'});\n *    input(obs, {isValid: isValidObs}, {type: 'email', placeholder: 'Your email...'});\n *    input(obs, {onInput: true}, {type: 'text'});\n */\nfunction input(obs, options, ...args) {\n    const isValid = options.isValid;\n    function setValue(elem) {\n        index_1.bundleChanges(() => {\n            obs.set(elem.value);\n            if (isValid) {\n                isValid.set(elem.validity.valid);\n            }\n        });\n    }\n    return index_1.dom('input', ...args, index_1.dom.prop('value', obs), (isValid ?\n        (elem) => index_1.dom.autoDisposeElem(elem, index_1.subscribe(obs, (use) => isValid.set(elem.checkValidity()))) :\n        null), options.onInput ? index_1.dom.on('input', (e, elem) => setValue(elem)) : null, index_1.dom.on('change', (e, elem) => setValue(elem)), index_1.dom.onKeyPress({ Enter: (e, elem) => setValue(elem) }));\n}\nexports.input = input;\n//# sourceMappingURL=input.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.select = void 0;\n/**\n * Select dropdown widget.\n */\nconst index_1 = require(\"../../index\");\nfunction unwrapMaybeObsArray(array) {\n    return Array.isArray(array) ? array : array.get();\n}\nfunction getOptionValue(option) {\n    return (typeof option === \"string\") ?\n        option : option.value;\n}\n/**\n * Creates a select dropdown widget. The observable `obs` reflects the value of the selected\n * option, and `optionArray` is an array (regular or observable) of option values and labels.\n * These may be either strings, or {label, value, disabled} objects.\n *\n * The type of value may be any type at all; it is opaque to this widget.\n *\n * If obs is set to an invalid or disabled value, then defLabel option is used to determine the\n * label that the select box will show, blank by default.\n *\n * Usage:\n *    const fruit = observable(\"apple\");\n *    select(fruit, [\"apple\", \"banana\", \"mango\"]);\n *\n *    const employee = observable(17);\n *    const employees = obsArray<IOption<number>>([\n *      {value: 12, label: \"Bob\", disabled: true},\n *      {value: 17, label: \"Alice\"},\n *      {value: 21, label: \"Eve\"},\n *    ]);\n *    select(employee, employees, {defLabel: \"Select employee:\"});\n */\nfunction select(obs, optionArray, options = {}) {\n    const { defLabel = \"\" } = options;\n    return index_1.dom('select', \n    // Include a hidden option to represent a default value. This one gets shown when none of the\n    // options are selected. This is more consistent when showing the first valid option.\n    index_1.dom('option', index_1.dom.hide(true), defLabel), \n    // Create all the option elements.\n    index_1.dom.forEach(optionArray, (option) => {\n        const obj = (typeof option === \"string\") ?\n            { value: option, label: option } : option;\n        // Note we only set 'selected' when an <option> is created; we are not subscribing to obs.\n        // This is to reduce the amount of subscriptions, esp. when number of options is large.\n        return index_1.dom('option', {\n            disabled: obj.disabled,\n            selected: obj.value === obs.get(),\n        }, obj.label);\n    }), \n    // When obs changes, update select's value; we do it after <options> have been created.\n    // Note that autoDisposeElem ensures the subscription is disposed with the 'select' element.\n    (elem) => index_1.dom.autoDisposeElem(elem, index_1.subscribe(obs, (use, obsValue) => {\n        const arr = unwrapMaybeObsArray(optionArray);\n        const index = arr.findIndex((item) => getOptionValue(item) === obsValue);\n        elem.selectedIndex = index + 1; // +1 for default option\n    })), \n    // When user picks a new item, use its value to update the observable.\n    index_1.dom.on('change', (e, elem) => {\n        const index = elem.selectedIndex;\n        const item = unwrapMaybeObsArray(optionArray)[index - 1]; // -1 for default option\n        // It should be impossible for the user to select an invalid option, but check just in case.\n        if (item !== undefined) {\n            obs.set(getOptionValue(item));\n        }\n    }));\n}\nexports.select = select;\n//# sourceMappingURL=select.js.map"]}