"use strict";
/**
 * Grain.js observables and computeds are similar to (and mostly inspired by) those in
 * Knockout.js. In fact, they can work together.
 *
 *  import {fromKo} from 'kowrap'
 *
 *  fromKo(koObservable)
 *
 * returns a Grain.js observable that mirrors the passed-in Knockout observable (which may be a
 * computed as well). Similarly,
 *
 *  import {toKo} from 'kowrap';
 *  import * as ko from 'knockout';
 *
 *  toKo(ko, observable)
 *
 * returns a Knockout.js observable that mirrows the passed-in Grain observable or computed. Note
 * that toKo() mus tbe called with the knockout module as an argument. This is to avoid adding
 * knockout as a dependency of grainjs.
 *
 * In both cases, calling fromKo/toKo twice on the same observable will return the same wrapper,
 * and subscriptions and disposal are appropriately set up to make usage seamless. In particular,
 * the returned wrapper should not be disposed; it's tied to the lifetime of the wrapped object.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupKoDisposal = exports.toKo = exports.KoWrapObs = exports.fromKo = void 0;
const domDispose_1 = require("./domDispose");
const observable_1 = require("./observable");
const fromKoWrappers = new WeakMap();
const toKoWrappers = new WeakMap();
/**
 * Returns a Grain.js observable which mirrors a Knockout observable.
 *
 * Do not dispose this wrapper, as it is shared by all code using koObs, and its lifetime is tied
 * to the lifetime of koObs. If unused, it consumes minimal resources, and should get garbage
 * collected along with koObs.
 */
function fromKo(koObs) {
    return fromKoWrappers.get(koObs) || fromKoWrappers.set(koObs, new KoWrapObs(koObs)).get(koObs);
}
exports.fromKo = fromKo;
/**
 * An Observable that wraps a Knockout observable, created via fromKo(). It keeps minimal overhead
 * when unused by only subscribing to the wrapped observable while it itself has subscriptions.
 *
 * This way, when unused, the only reference is from the wrapper to the wrapped object. KoWrapObs
 * should not be disposed; its lifetime is tied to that of the wrapped object.
 */
class KoWrapObs extends observable_1.Observable {
    constructor(_koObs) {
        super(_koObs.peek());
        this._koObs = _koObs;
        this._koSub = null;
        this.setListenerChangeCB((hasListeners) => {
            if (!hasListeners) {
                this._koSub.dispose();
                this._koSub = null;
            }
            else if (!this._koSub) {
                // TODO this is a little hack, really, BaseObservable should expose a way to set the value
                // directly by derived classes, i.e. a protected setter.
                this._value = this._koObs.peek();
                this._koSub = this._koObs.subscribe((val) => this.setAndTrigger(val));
            }
        });
    }
    get() { return this._koObs.peek(); }
    set(value) { observable_1.bundleChanges(() => this._koObs(value)); }
    dispose() { throw new Error("KoWrapObs should not be disposed"); }
}
exports.KoWrapObs = KoWrapObs;
/**
 * Returns a Knockout observable which mirrors a Grain.js observable.
 */
function toKo(knockout, grainObs) {
    const prevKoObs = toKoWrappers.get(grainObs);
    if (prevKoObs) {
        return prevKoObs;
    }
    const newKoObs = knockout.observable(grainObs.get());
    toKoWrappers.set(grainObs, newKoObs);
    grainObs.addListener((val) => newKoObs(val));
    return newKoObs;
}
exports.toKo = toKo;
// Marker for when knockout-disposal integration has already been setup.
let koDisposalIsSetup = false;
/**
 * Set up integration between grainjs and knockout disposal. Knockout does cleanup using
 * ko.removeNode / ko.cleanNode (it also takes care of JQuery cleanup if needed). GrainJS does
 * cleanup using dom.domDispose(). By default these don't know about each other.
 *
 * If you mix the two libraries, however, disposing an element may need to trigger disposers
 * registered by either library.
 *
 * This method ensures that this happens.
 *
 * Note: grainjs disposes text nodes too, but nothing relies on it. When disposal is triggered via
 * knockout, we are forced to rely on knockout's node traversal which ignores text nodes.
 */
function setupKoDisposal(ko) {
    // Ensure we don't do the setup more than once, or things will get called multiple times.
    if (koDisposalIsSetup) {
        return;
    }
    koDisposalIsSetup = true;
    const koDomNodeDisposal = ko.utils.domNodeDisposal;
    // Knockout by default has an external-data-cleanup func set to cleanup JQuery. Whatever it is
    // set to, we will continue calling it, and also will call grainjs domDisposeNode.
    const origKoCleanExternalData = koDomNodeDisposal.cleanExternalData;
    // The original function called by grainjs to clean nodes recursively. We'll override it.
    const origGrainDisposeRecursive = domDispose_1.domDisposeHooks.disposeRecursive;
    // New function called by knockout to do extra cleanup. Now calls grainjs single-node cleanup.
    // (In knockout, we can only override single-node cleanup.)
    function newKoCleanExternalData(node) {
        origKoCleanExternalData(node);
        domDispose_1.domDisposeHooks.disposeNode(node);
    }
    // Function called by grainjs to clean nodes recursively. We override the recursive cleanup
    // function to call the recursive knockout cleanup (letting knockout do the dom traversal it
    // normally does).
    function newGrainDisposeRecursive(node) {
        origGrainDisposeRecursive(node);
        // While doing knockout cleanup, do NOT have it call grainjs cleanup too, as that would cause
        // multiple unnecessary traversals of DOM.
        koDomNodeDisposal.cleanExternalData = origKoCleanExternalData;
        try {
            ko.cleanNode(node);
        }
        finally {
            koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;
        }
    }
    // Use knockout and grainjs hooks to actually set the new cleanup functions.
    koDomNodeDisposal.cleanExternalData = newKoCleanExternalData;
    domDispose_1.domDisposeHooks.disposeRecursive = newGrainDisposeRecursive;
}
exports.setupKoDisposal = setupKoDisposal;
//# sourceMappingURL=kowrap.js.map