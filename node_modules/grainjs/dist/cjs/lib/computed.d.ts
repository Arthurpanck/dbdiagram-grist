/**
 * computed.js implements a computed observable, whose value depends on other observables and gets
 * recalculated automatically when they change.
 *
 * E.g. if we have some existing observables (which may themselves be instances of `computed`),
 * we can create a computed that subscribes to them explicitly:
 *  let obs1 = observable(5), obs2 = observable(12);
 *  let computed1 = computed(obs1, obs2, (use, v1, v2) => v1 + v2);
 *
 * or implicitly by using `use(obs)` function:
 *  let computed2 = computed(use => use(obs1) + use(obs2));
 *
 * In either case, computed1.get() and computed2.get() will have the value 17. If obs1 or obs2 is
 * changed, computed1 and computed2 will get recomputed automatically.
 *
 * Creating a computed allows any number of dependencies to be specified explicitly, and their
 * values will be passed to the read() callback. These may be combined with automatic dependencies
 * detected using use(). Note that constructor dependencies have less overhead.
 *
 *  let val = computed(...deps, ((use, ...depValues) => READ_CALLBACK));
 *
 * You may specify a `write` callback by calling `onWrite(WRITE_CALLBACK)`, which will be called
 * whenever set() is called on the computed by its user. If a `write` bacllback is not specified,
 * calling `set` on a computed observable will throw an exception.
 *
 * Note that pureComputed.js offers a variation of computed() with the same interface, but which
 * stays unsubscribed from dependencies while it itself has no subscribers.
 *
 * A computed may be used with a disposable value using `use.owner` as the value's owner. E.g.
 *    let val = computed((use) => Foo.create(use.owner, use(a), use(b)));
 *
 * When the computed() is re-evaluated, and when it itself is disposed, it disposes the previously
 * owned value. Note that only the pattern above works, i.e. use.owner may only be used to take
 * ownership of the same disposable that the callback returns.
 */
import { DepItem } from './_computed_queue';
import { IDisposableOwnerT } from './dispose';
import { BaseObservable as Obs, Observable } from './observable';
import { ISubscribable, UseCBOwner as UseCB } from './subscribe';
declare type Owner<T> = IDisposableOwnerT<Computed<T>> | null;
export declare class Computed<T> extends Observable<T> {
    static create<T>(owner: Owner<T>, cb: (use: UseCB) => T): Computed<T>;
    static create<T, A>(owner: Owner<T>, a: Obs<A>, cb: (use: UseCB, a: A) => T): Computed<T>;
    static create<T, A, B>(owner: Owner<T>, a: Obs<A>, b: Obs<B>, cb: (use: UseCB, a: A, b: B) => T): Computed<T>;
    static create<T, A, B, C>(owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>, cb: (use: UseCB, a: A, b: B, c: C) => T): Computed<T>;
    static create<T, A, B, C, D>(owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): Computed<T>;
    static create<T, A, B, C, D, E>(owner: Owner<T>, a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;
    private _callback;
    private _write;
    private _sub;
    /**
     * Internal constructor for a Computed observable. You should use computed() function instead.
     */
    constructor(callback: (use: UseCB, ...args: any[]) => T, dependencies: ISubscribable[]);
    /**
     * Used by subscriptions to keep track of dependencies.
     */
    _getDepItem(): DepItem;
    /**
     * "Sets" the value of the computed by calling the write() callback if one was provided in the
     * constructor. Throws an error if there was no such callback (not a "writable" computed).
     * @param {Object} value: The value to pass to the write() callback.
     */
    set(value: T): void;
    /**
     * Set callback to call when this.set(value) is called, to make it a writable computed. If not
     * set, attempting to write to this computed will throw an exception.
     */
    onWrite(writeFunc: (value: T) => void): Computed<T>;
    /**
     * Disposes the computed, unsubscribing it from all observables it depends on.
     */
    dispose(): void;
    private _read;
}
/**
 * This is the type-checking interface for computed(), which allows TypeScript to do helpful
 * type-checking when using it. We can only support a fixed number of argumnets (explicit
 * dependencies), but 5 should almost always be enough.
 */
export declare function computed<T>(cb: (use: UseCB) => T): Computed<T>;
export declare function computed<T, A>(a: Obs<A>, cb: (use: UseCB, a: A) => T): Computed<T>;
export declare function computed<T, A, B>(a: Obs<A>, b: Obs<B>, cb: (use: UseCB, a: A, b: B) => T): Computed<T>;
export declare function computed<T, A, B, C>(a: Obs<A>, b: Obs<B>, c: Obs<C>, cb: (use: UseCB, a: A, b: B, c: C) => T): Computed<T>;
export declare function computed<T, A, B, C, D>(a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): Computed<T>;
export declare function computed<T, A, B, C, D, E>(a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): Computed<T>;
export {};
