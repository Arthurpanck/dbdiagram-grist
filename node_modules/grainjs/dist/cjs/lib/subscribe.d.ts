/**
 * subscribe.js implements subscriptions to several observables at once.
 *
 * E.g. if we have some existing observables (which may be instances of `computed`),
 * we can subscribe to them explicitly:
 *    let obs1 = observable(5), obs2 = observable(12);
 *    subscribe(obs1, obs2, (use, v1, v2) => console.log(v1, v2));
 *
 * or implicitly by using `use(obs)` function, which allows dynamic subscriptions:
 *    subscribe(use => console.log(use(obs1), use(obs2)));
 *
 * In either case, if obs1 or obs2 is changed, the callbacks will get called automatically.
 *
 * Creating a subscription allows any number of dependencies to be specified explicitly, and their
 * values will be passed to the callback(). These may be combined with automatic dependencies
 * detected using use(). Note that constructor dependencies have less overhead.
 *
 *    subscribe(...deps, ((use, ...depValues) => READ_CALLBACK));
 */
import { DepItem } from './_computed_queue';
import { IDisposableOwner } from './dispose';
import { Listener } from './emit';
import { IKnockoutReadObservable } from './kowrap';
import { BaseObservable as Obs } from './observable';
export interface ISubscribableObs {
    _getDepItem(): DepItem | null;
    addListener(callback: (val: any, prev: any) => void, optContext?: object): Listener;
    get(): any;
}
export declare type ISubscribable = ISubscribableObs | IKnockoutReadObservable<any>;
export declare type InferUseType<TObs extends Obs<any> | IKnockoutReadObservable<any>> = TObs extends Obs<infer T> ? T : TObs extends {
    peek(): infer U;
} ? U : never;
export declare type UseCB = <TObs extends Obs<any> | IKnockoutReadObservable<any>>(obs: TObs) => InferUseType<TObs>;
export interface UseCBOwner extends UseCB {
    owner: IDisposableOwner;
}
export declare class Subscription {
    private readonly _depItem;
    private readonly _dependencies;
    private readonly _depListeners;
    private _dynDeps;
    private _callback;
    private _useFunc;
    /**
     * Internal constructor for a Subscription. You should use subscribe() function instead.
     * The last owner argument is used by computed() to make itself available as the .owner property
     * of the 'use' function that gets passed to the callback.
     */
    constructor(callback: (use: UseCB, ...args: any[]) => void, dependencies: ReadonlyArray<ISubscribable>, owner?: any);
    /**
     * Disposes the computed, unsubscribing it from all observables it depends on.
     */
    dispose(): void;
    /**
     * For use by computed(): returns this subscription's hook into the _computed_queue.
     */
    _getDepItem(): DepItem;
    /**
     * @private
     * Gets called when the callback calls `use(obs)` for an observable. It creates a
     * subscription to `obs` if one doesn't yet exist.
     * @param {Observable} obs: The observable being used as a dependency.
     */
    private _useDependency;
    /**
     * @private
     * Calls the callback() with appropriate args, and updates subscriptions when it is done.
     * I.e. adds dynamic subscriptions created via `use(obs)`, and disposes those no longer used.
     */
    private _evaluate;
    /**
     * @private
     * Subscribes this computed to another observable that it depends on.
     * @param {Observable} obs: The observable to subscribe to.
     * @returns {Listener} Listener object.
     */
    private _subscribeTo;
    /**
     * @private
     * Adds this item to the recompute queue.
     */
    private _enqueue;
}
/**
 * This is the type-checking interface for subscribe(), which allows TypeScript to do helpful
 * type-checking when using it. We can only support a fixed number of argumnets (explicit
 * dependencies), but 5 should almost always be enough.
 */
export declare function subscribe(cb: (use: UseCB) => void): Subscription;
export declare function subscribe<A>(a: Obs<A>, cb: (use: UseCB, a: A) => void): Subscription;
export declare function subscribe<A, B>(a: Obs<A>, b: Obs<B>, cb: (use: UseCB, a: A, b: B) => void): Subscription;
export declare function subscribe<A, B, C>(a: Obs<A>, b: Obs<B>, c: Obs<C>, cb: (use: UseCB, a: A, b: B, c: C) => void): Subscription;
export declare function subscribe<A, B, C, D>(a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => void): Subscription;
export declare function subscribe<A, B, C, D, E>(a: Obs<A>, b: Obs<B>, c: Obs<C>, d: Obs<D>, e: Obs<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => void): Subscription;
