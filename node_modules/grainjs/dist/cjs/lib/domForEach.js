"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEach = void 0;
const domComputed_1 = require("./domComputed");
const domDispose_1 = require("./domDispose");
const domImpl_1 = require("./domImpl");
const obsArray_1 = require("./obsArray");
// Use the browser globals in a way that allows replacing them with mocks in tests.
const browserGlobals_1 = require("./browserGlobals");
/**
 * Creates DOM elements for each element of an observable array. As the array is changed, children
 * are added or removed. This works for any array-valued observable, and for obsArray() and
 * computedArray() it works more efficiently for simple changes.
 *
 * The given itemCreateFunc() should return a single DOM node for each item, or null to skip that
 * item. It is called for new items whenever they are spliced in, or the array replaced. The
 * forEach() owns the created nodes, and runs domDispose() on them when they are spliced out.
 *
 * If the created nodes are removed from their parent externally, forEach() will cope with it, but
 * will consider these elements as no longer owned, and will not run domDispose() on them.
 *
 * Note that itemCreateFunc() does not receive an index: an index would only be correct at the
 * time the item is created, and would not reflect further changes to the array.
 *
 * If you'd like to map the DOM node back to its source item, use dom.data() and dom.getData() in
 * itemCreateFunc().
 */
function forEach(obsArray, itemCreateFunc) {
    const markerPre = browserGlobals_1.G.document.createComment('a');
    const markerPost = browserGlobals_1.G.document.createComment('b');
    return [markerPre, markerPost, (elem) => {
            if (Array.isArray(obsArray)) {
                domComputed_1.replaceContent(markerPre, markerPost, obsArray.map(itemCreateFunc));
                return;
            }
            const nodes = obsArray_1.computedArray(obsArray, itemCreateFunc);
            // Be sure to dispose the newly-created array when the DOM it's associated with is gone.
            domDispose_1.autoDisposeElem(markerPost, nodes);
            nodes.addListener((newArr, oldArr, splice) => {
                if (splice) {
                    // Remove the elements that are gone.
                    for (const node of splice.deleted) {
                        if (node && node.parentNode === elem) {
                            domDispose_1.domDispose(node);
                            elem.removeChild(node);
                        }
                    }
                    if (splice.numAdded > 0) {
                        // Find a valid child immediately following the spliced out portion, for DOM insertion.
                        const endIndex = splice.start + splice.numAdded;
                        let nextElem = markerPost;
                        for (let i = endIndex; i < newArr.length; i++) {
                            const node = newArr[i];
                            if (node && node.parentNode === elem) {
                                nextElem = node;
                                break;
                            }
                        }
                        // Insert the new elements.
                        const content = domImpl_1.frag(newArr.slice(splice.start, endIndex));
                        elem.insertBefore(content, nextElem);
                    }
                }
                else {
                    domComputed_1.replaceContent(markerPre, markerPost, newArr);
                }
            });
            domComputed_1.replaceContent(markerPre, markerPost, nodes.get());
        }];
}
exports.forEach = forEach;
//# sourceMappingURL=domForEach.js.map