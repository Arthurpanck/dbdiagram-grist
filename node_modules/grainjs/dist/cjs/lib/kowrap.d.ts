/**
 * Grain.js observables and computeds are similar to (and mostly inspired by) those in
 * Knockout.js. In fact, they can work together.
 *
 *  import {fromKo} from 'kowrap'
 *
 *  fromKo(koObservable)
 *
 * returns a Grain.js observable that mirrors the passed-in Knockout observable (which may be a
 * computed as well). Similarly,
 *
 *  import {toKo} from 'kowrap';
 *  import * as ko from 'knockout';
 *
 *  toKo(ko, observable)
 *
 * returns a Knockout.js observable that mirrows the passed-in Grain observable or computed. Note
 * that toKo() mus tbe called with the knockout module as an argument. This is to avoid adding
 * knockout as a dependency of grainjs.
 *
 * In both cases, calling fromKo/toKo twice on the same observable will return the same wrapper,
 * and subscriptions and disposal are appropriately set up to make usage seamless. In particular,
 * the returned wrapper should not be disposed; it's tied to the lifetime of the wrapped object.
 */
import { Observable } from './observable';
export interface IKnockoutObservable<T> extends IKnockoutReadObservable<T> {
    (val: T): void;
}
export interface IKnockoutReadObservable<T> {
    (): T;
    peek(): T;
    subscribe(callback: (newValue: T) => void, target?: any, event?: "change"): any;
    getSubscriptionsCount(): number;
}
export declare type InferKoType<KObs extends IKnockoutReadObservable<any>> = KObs extends {
    peek(): infer T;
} ? T : never;
/**
 * Returns a Grain.js observable which mirrors a Knockout observable.
 *
 * Do not dispose this wrapper, as it is shared by all code using koObs, and its lifetime is tied
 * to the lifetime of koObs. If unused, it consumes minimal resources, and should get garbage
 * collected along with koObs.
 */
export declare function fromKo<KObs extends IKnockoutObservable<any>>(koObs: KObs): Observable<InferKoType<KObs>>;
/**
 * An Observable that wraps a Knockout observable, created via fromKo(). It keeps minimal overhead
 * when unused by only subscribing to the wrapped observable while it itself has subscriptions.
 *
 * This way, when unused, the only reference is from the wrapper to the wrapped object. KoWrapObs
 * should not be disposed; its lifetime is tied to that of the wrapped object.
 */
export declare class KoWrapObs<T> extends Observable<T> {
    private _koObs;
    private _koSub;
    constructor(_koObs: IKnockoutObservable<T>);
    get(): T;
    set(value: T): void;
    dispose(): void;
}
export interface IKnockoutModule {
    observable<T>(value: T): IKnockoutObservable<T>;
    cleanNode(node: Node): void;
}
/**
 * Returns a Knockout observable which mirrors a Grain.js observable.
 */
export declare function toKo<T>(knockout: IKnockoutModule, grainObs: Observable<T>): IKnockoutObservable<T>;
/**
 * Set up integration between grainjs and knockout disposal. Knockout does cleanup using
 * ko.removeNode / ko.cleanNode (it also takes care of JQuery cleanup if needed). GrainJS does
 * cleanup using dom.domDispose(). By default these don't know about each other.
 *
 * If you mix the two libraries, however, disposing an element may need to trigger disposers
 * registered by either library.
 *
 * This method ensures that this happens.
 *
 * Note: grainjs disposes text nodes too, but nothing relies on it. When disposal is triggered via
 * knockout, we are forced to rely on knockout's node traversal which ignores text nodes.
 */
export declare function setupKoDisposal(ko: IKnockoutModule): void;
