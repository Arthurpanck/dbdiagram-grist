/**
 * pureComputed.js implements a variant of computed() suitable for use with a pure read function
 * (free of side-effects). A pureComputed is only subscribed to its dependencies when something is
 * subscribed to it. At other times, it is not subscribed to anything, and calls to `get()` will
 * recompute its value each time by calling its read() function.
 *
 * Its syntax and usage are otherwise exactly as for a computed.
 *
 * In addition to being cheaper when unused, a pureComputed() also avoids leaking memory when
 * unused (since it's not registered with dependencies), so it is not necessary to dispose it.
 */
import { DepItem } from './_computed_queue';
import { Observable } from './observable';
import { ISubscribable, UseCB } from './subscribe';
export declare class PureComputed<T> extends Observable<T> {
    private _callback;
    private _write;
    private _sub;
    private readonly _dependencies;
    private _inCall;
    /**
     * Internal constructor for a PureComputed. You should use pureComputed() function instead.
     */
    constructor(callback: (use: UseCB, ...args: any[]) => T, dependencies: ReadonlyArray<ISubscribable>);
    _getDepItem(): DepItem;
    get(): T;
    /**
     * "Sets" the value of the pure computed by calling the write() callback if one was provided in
     * the constructor. Throws an error if there was no such callback (not a "writable" computed).
     * @param {Object} value: The value to pass to the write() callback.
     */
    set(value: T): void;
    /**
     * Set callback to call when this.set(value) is called, to make it a writable computed. If not
     * set, attempting to write to this computed will throw an exception.
     */
    onWrite(writeFunc: (value: T) => void): PureComputed<T>;
    /**
     * Disposes the pureComputed, unsubscribing it from all observables it depends on.
     */
    dispose(): void;
    private _activate;
    private _onListenerChange;
    private _read;
}
/**
 * This is the type-checking interface for pureComputed(), which allows TypeScript to do helpful
 * type-checking when using it. We can only support a fixed number of argumnets (explicit
 * dependencies), but 5 should almost always be enough.
 */
export declare function pureComputed<T>(cb: (use: UseCB) => T): PureComputed<T>;
export declare function pureComputed<A, T>(a: Observable<A>, cb: (use: UseCB, a: A) => T): PureComputed<T>;
export declare function pureComputed<A, B, T>(a: Observable<A>, b: Observable<B>, cb: (use: UseCB, a: A, b: B) => T): PureComputed<T>;
export declare function pureComputed<A, B, C, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, cb: (use: UseCB, a: A, b: B, c: C) => T): PureComputed<T>;
export declare function pureComputed<A, B, C, D, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>, cb: (use: UseCB, a: A, b: B, c: C, d: D) => T): PureComputed<T>;
export declare function pureComputed<A, B, C, D, E, T>(a: Observable<A>, b: Observable<B>, c: Observable<C>, d: Observable<D>, e: Observable<E>, cb: (use: UseCB, a: A, b: B, c: C, d: D, e: E) => T): PureComputed<T>;
