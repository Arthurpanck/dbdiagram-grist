/**
 * ObsArray extends a plain Observable to allow for more efficient observation of array changes.
 *
 * As for any array-valued Observable, when the contents of the observed array changes, the
 * listeners get called with new and previous values which are the same array. For simple changes,
 * such as those made with .push() and .splice() methods, ObsArray allows for more efficient
 * handling of the change by calling listeners with splice info in the third argument.
 *
 * This module also provides computedArray(), which allows mapping each item of an ObsArray
 * through a function, passing through splice info for efficient handling of small changes. It
 * also allows mapping an observable or a computed whose value is an ObsArray.
 *
 * There is no need or benefit in using computedArray() if you have a computed() that returns a
 * plain array. It is specifically for the case when you want to preserve the efficiency of
 * ObsArray when you map its values.
 *
 * Both ObsArray and ComputedArray may be used with disposable elements as their owners. E.g.
 *
 *    const arr = obsArray<D>();
 *    arr.push(D.create(arr, "x"), D.create(arr, "y"));
 *    arr.pop();      // Element "y" gets disposed.
 *    arr.dispose();  // Element "x" gets disposed.
 *
 *    const values = obsArray<string>();
 *    const compArr = computedArray<D>(values, (val, i, compArr) => D.create(compArr, val));
 *    values.push("foo", "bar");      // D("foo") and D("bar") get created
 *    values.pop();                   // D("bar") gets disposed.
 *    compArr.dispose();              // D("foo") gets disposed.
 *
 * Note that only the pattern above works: obsArray (or compArray) may only be used to take
 * ownership of those disposables that are added to it as array elements.
 */
import { IDisposable, IDisposableOwnerT } from './dispose';
import { Listener } from './emit';
import { BaseObservable, Observable } from './observable';
/**
 * Either an observable or a plain array of T. This is useful for functions like dom.forEach()
 * which are convenient to have available for both.
 */
export declare type MaybeObsArray<T> = BaseObservable<T[]> | T[];
/**
 * Info about a modification to ObsArray contents. It is included as a third argument to change
 * listeners when available. When not available, listeners should assume that the array changed
 * completely.
 */
export interface IObsArraySplice<T> {
    start: number;
    numAdded: number;
    deleted: T[];
}
export declare type ISpliceListener<T, C> = (this: C, val: T[], prev: T[], change?: IObsArraySplice<T>) => void;
/**
 * ObsArray<T> is essentially an array-valued observable. The main difference is that it may be
 * used as an owner for disposable array elements.
 */
export declare class ObsArray<T> extends BaseObservable<T[]> {
    private _ownedItems?;
    addListener(callback: ISpliceListener<T, void>): Listener;
    addListener<C>(callback: ISpliceListener<T, C>, context: C): Listener;
    autoDispose(value: T & IDisposable): T & IDisposable;
    dispose(): void;
    protected _setWithSplice(value: T[], splice: IObsArraySplice<T>): void;
    protected _disposeOwned(splice?: IObsArraySplice<T>): void;
}
/**
 * MutableObsArray<T> adds array-like mutation methods which emit events with splice info, to
 * allow more efficient processing of such changes. It is created with obsArray<T>().
 */
export declare class MutableObsArray<T> extends ObsArray<T> {
    push(...args: T[]): number;
    pop(): T | undefined;
    unshift(...args: T[]): number;
    shift(): T | undefined;
    splice(start: number, deleteCount?: number, ...newValues: T[]): T[];
}
/**
 * Creates a new MutableObsArray with an optional initial value, defaulting to the empty array.
 * It is essentially the same as observable<T[]>, but with array-like mutation methods.
 */
export declare function obsArray<T>(value?: T[]): MutableObsArray<T>;
/**
 * See computedArray() below for documentation.
 */
export declare class ComputedArray<T, U> extends ObsArray<U> {
    private _mapper;
    private _sub;
    private _source?;
    private _listener?;
    private _lastSplice?;
    constructor(obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>, _mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U);
    dispose(): void;
    private _syncMap;
    private _unsync;
    private _rebuild;
    private _applySplice;
    private _recordChange;
}
/**
 * Returns an ObsArray that maps all elements of the passed-in ObsArray through a mapper function.
 * Also accepts an observable (e.g. a computed) whose value is an ObsArray. Usage:
 *
 *    computedArray(obsArray, mapper)
 *
 * The result is entirely analogous to:
 *
 *     computed((use) => use(obsArray).map(mapper))       // for ObsArray
 *     computed((use) => use(use(obsArray)).map(mapper))  // for Observable<ObsArray>
 *
 * The benefit of computedArray() is that a small change to the source array (e.g. one item
 * added or removed), causes a small change to the mapped array, rather than a full rebuild.
 *
 * This is useful with an ObsArray or with an observable whose value is an ObsArray, and also
 * when the computed array owns its disposable items.
 *
 * Note that the mapper function is called with (item, index, array) as for a standard
 * array.map(), but that the index is only accurate at the time of the call, and will stop
 * reflecting the true index if more items are inserted into the array later.
 */
export declare function computedArray<T, U>(obsArr: BaseObservable<T[]> | Observable<BaseObservable<T[]>>, mapper: (item: T, index: number, arr: ComputedArray<T, U>) => U): ObsArray<U>;
/**
 * Returns a new observable representing an index into this array. It can be read and written, and
 * its value is clamped to be a valid index. The index is only null if the array is empty.
 *
 * As the array changes, the index is adjusted to continue pointing to the same element. If the
 * pointed element is deleted, the index is adjusted to after the deletion point.
 *
 * The returned observable has an additional .setLive(bool) method. While set to false, the
 * observable will not be adjusted as the array changes, except to keep it valid.
 */
export declare function makeLiveIndex<T>(owner: IDisposableOwnerT<LiveIndex> | null, obsArr: ObsArray<T>, initialIndex?: number): LiveIndex;
export declare class LiveIndex extends Observable<number | null> {
    private _obsArray;
    private _listener;
    private _isLive;
    constructor(_obsArray: ObsArray<any>, initialIndex?: number);
    set(index: number | null): void;
    setLive(value: boolean): void;
    dispose(): void;
    private _onArrayChange;
}
