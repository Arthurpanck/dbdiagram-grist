"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noTestId = exports.makeTestId = exports.getData = exports.data = exports.dataElem = exports.clsPrefix = exports.cls = exports.clsElem = exports.hide = exports.hideElem = exports.show = exports.showElem = exports.prop = exports.propElem = exports.style = exports.styleElem = exports.text = exports.textElem = exports.boolAttr = exports.boolAttrElem = exports.attr = exports.attrElem = exports.attrs = exports.attrsElem = void 0;
const binding_1 = require("./binding");
const domDispose_1 = require("./domDispose");
// Use the browser globals in a way that allows replacing them with mocks in tests.
const browserGlobals_1 = require("./browserGlobals");
/**
 * Private global map for associating arbitrary data with DOM. It's a WeakMap, so does not prevent
 * values from being garbage collected when the owning DOM elements are no longer used.
 */
const _dataMap = new WeakMap();
/**
 * Sets multiple attributes of a DOM element. The `attrs()` variant takes no `elem` argument.
 * Null and undefined values are omitted, and booleans are either omitted or set to empty string.
 * @param {Object} attrsObj: Object mapping attribute names to attribute values.
 */
function attrsElem(elem, attrsObj) {
    for (const key of Object.keys(attrsObj)) {
        const val = attrsObj[key];
        if (val != null && val !== false) {
            elem.setAttribute(key, val === true ? '' : val);
        }
    }
}
exports.attrsElem = attrsElem;
function attrs(attrsObj) {
    return (elem) => attrsElem(elem, attrsObj);
}
exports.attrs = attrs;
/**
 * Sets an attribute of a DOM element to the given value. Removes the attribute when the value is
 * null or undefined. The `attr()` variant takes no `elem` argument, and `attrValue` may be an
 * observable or function.
 * @param {Element} elem: The element to update.
 * @param {String} attrName: The name of the attribute to bind, e.g. 'href'.
 * @param {String|null} attrValue: The string value or null to remove the attribute.
 */
function attrElem(elem, attrName, attrValue) {
    if (attrValue === null || attrValue === undefined) {
        elem.removeAttribute(attrName);
    }
    else {
        elem.setAttribute(attrName, attrValue);
    }
}
exports.attrElem = attrElem;
function attr(attrName, attrValueObs) {
    return (elem) => binding_1.subscribeElem(elem, attrValueObs, (val) => attrElem(elem, attrName, val));
}
exports.attr = attr;
/**
 * Sets or removes a boolean attribute of a DOM element. According to the spec, empty string is a
 * valid true value for the attribute, and the false value is indicated by the attribute's absence.
 * The `boolAttr()` variant takes no `elem`, and `boolValue` may be an observable or function.
 * @param {Element} elem: The element to update.
 * @param {String} attrName: The name of the attribute to bind, e.g. 'checked'.
 * @param {Boolean} boolValue: Boolean value whether to set or unset the attribute.
 */
function boolAttrElem(elem, attrName, boolValue) {
    attrElem(elem, attrName, boolValue ? '' : null);
}
exports.boolAttrElem = boolAttrElem;
function boolAttr(attrName, boolValueObs) {
    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => boolAttrElem(elem, attrName, val));
}
exports.boolAttr = boolAttr;
/**
 * Adds a text node to the element. The `text()` variant takes no `elem`, and `value` may be an
 * observable or function.
 * @param {Element} elem: The element to update.
 * @param {String} value: The text value to add.
 */
function textElem(elem, value) {
    elem.appendChild(browserGlobals_1.G.document.createTextNode(value));
}
exports.textElem = textElem;
function text(valueObs) {
    return (elem) => {
        const textNode = browserGlobals_1.G.document.createTextNode('');
        binding_1.subscribeElem(elem, valueObs, (val) => { textNode.nodeValue = val; });
        elem.appendChild(textNode);
    };
}
exports.text = text;
/**
 * Sets a style property of a DOM element to the given value. The `style()` variant takes no
 * `elem`, and `value` may be an observable or function.
 * @param {Element} elem: The element to update.
 * @param {String} property: The name of the style property to update, e.g. 'fontWeight'.
 * @param {String} value: The value for the property.
 */
function styleElem(elem, property, value) {
    elem.style[property] = value;
}
exports.styleElem = styleElem;
function style(property, valueObs) {
    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => styleElem(elem, property, val));
}
exports.style = style;
/**
 * Sets the property of a DOM element to the given value.
 * The `prop()` variant takes no `elem`, and `value` may be an observable or function.
 * @param {Element} elem: The element to update.
 * @param {String} property: The name of the property to update, e.g. 'disabled'.
 * @param {Object} value: The value for the property.
 */
function propElem(elem, property, value) {
    elem[property] = value;
}
exports.propElem = propElem;
function prop(property, valueObs) {
    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => propElem(elem, property, val));
}
exports.prop = prop;
/**
 * Shows or hides the element depending on a boolean value. Note that the element must be visible
 * initially (i.e. unsetting style.display should show it).
 * The `show()` variant takes no `elem`, and `boolValue` may be an observable or function.
 * @param {Element} elem: The element to update.
 * @param {Boolean} boolValue: True to show the element, false to hide it.
 */
function showElem(elem, boolValue) {
    elem.style.display = boolValue ? '' : 'none';
}
exports.showElem = showElem;
function show(boolValueObs) {
    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => showElem(elem, val));
}
exports.show = show;
/**
 * The opposite of show, hiding the element when boolValue is true.
 * The `hide()` variant takes no `elem`, and `boolValue` may be an observable or function.
 * @param {Element} elem: The element to update.
 * @param {Boolean} boolValue: True to hide the element, false to show it.
 */
function hideElem(elem, boolValue) {
    elem.style.display = boolValue ? 'none' : '';
}
exports.hideElem = hideElem;
function hide(boolValueObs) {
    return (elem) => binding_1.subscribeElem(elem, boolValueObs, (val) => hideElem(elem, val));
}
exports.hide = hide;
/**
 * Sets or toggles the given css class className.
 */
function clsElem(elem, className, boolValue = true) {
    elem.classList.toggle(className, Boolean(boolValue));
}
exports.clsElem = clsElem;
function cls(className, boolValue) {
    if (typeof className !== 'string') {
        return _clsDynamicPrefix('', className);
    }
    else if (!boolValue || typeof boolValue === 'boolean') {
        return (elem) => clsElem(elem, className, boolValue);
    }
    else {
        return (elem) => binding_1.subscribeElem(elem, boolValue, (val) => clsElem(elem, className, val));
    }
}
exports.cls = cls;
function clsPrefix(prefix, className, boolValue) {
    if (typeof className !== 'string') {
        return _clsDynamicPrefix(prefix, className);
    }
    else {
        return cls(prefix + className, boolValue);
    }
}
exports.clsPrefix = clsPrefix;
function _clsDynamicPrefix(prefix, className) {
    return (elem) => {
        let prevClass = null;
        binding_1.subscribeElem(elem, className, (name) => {
            if (prevClass) {
                elem.classList.remove(prevClass);
            }
            prevClass = name ? prefix + name : null;
            if (prevClass) {
                elem.classList.add(prevClass);
            }
        });
    };
}
/**
 * Associate arbitrary data with a DOM element. The `data()` variant takes no `elem`, and `value`
 * may be an observable or function.
 * @param {Element} elem: The element with which to associate data.
 * @param {String} key: Key to identify this piece of data among others attached to elem.
 * @param {Object} value: Arbitrary value to associate with elem.
 */
function dataElem(elem, key, value) {
    const obj = _dataMap.get(elem);
    if (obj) {
        obj[key] = value;
    }
    else {
        domDispose_1.onDisposeElem(elem, () => _dataMap.delete(elem));
        _dataMap.set(elem, { [key]: value });
    }
}
exports.dataElem = dataElem;
function data(key, valueObs) {
    return (elem) => binding_1.subscribeElem(elem, valueObs, (val) => dataElem(elem, key, val));
}
exports.data = data;
function getData(elem, key) {
    const obj = _dataMap.get(elem);
    return obj && obj[key];
}
exports.getData = getData;
/**
 * See documentation for TestId above.
 */
function makeTestId(prefix) {
    return clsPrefix.bind(null, prefix);
}
exports.makeTestId = makeTestId;
/**
 * See documentation for TestId above.
 */
const noTestId = (name) => null;
exports.noTestId = noTestId;
//# sourceMappingURL=domMethods.js.map