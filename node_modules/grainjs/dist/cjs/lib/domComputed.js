"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeOwned = exports.maybe = exports.domComputedOwned = exports.domComputed = exports.replaceContent = void 0;
const binding_1 = require("./binding");
const dispose_1 = require("./dispose");
const domDispose_1 = require("./domDispose");
const domImpl_1 = require("./domImpl");
// Use the browser globals in a way that allows replacing them with mocks in tests.
const browserGlobals_1 = require("./browserGlobals");
/**
 * Replaces the content between nodeBefore and nodeAfter, which should be two siblings within the
 * same parent node. New content may be anything allowed as an argument to dom(), including null
 * to insert nothing. Runs disposers, if any, on all removed content.
 */
function replaceContent(nodeBefore, nodeAfter, content) {
    const elem = nodeBefore.parentNode;
    if (elem) {
        let next;
        for (let n = nodeBefore.nextSibling; n && n !== nodeAfter; n = next) {
            next = n.nextSibling;
            domDispose_1.domDispose(n);
            elem.removeChild(n);
        }
        if (content) {
            elem.insertBefore(content instanceof browserGlobals_1.G.Node ? content : domImpl_1.frag(content), nodeAfter);
        }
    }
}
exports.replaceContent = replaceContent;
function domComputed(valueObs, contentFunc = identity) {
    const markerPre = browserGlobals_1.G.document.createComment('a');
    const markerPost = browserGlobals_1.G.document.createComment('b');
    // Function is added after markerPre and markerPost, so that it runs once they have already been
    // attached to elem (the parent element).
    return [markerPre, markerPost, (elem) => {
            binding_1.subscribeElem(markerPost, valueObs, (value) => replaceContent(markerPre, markerPost, contentFunc(value)));
        }];
}
exports.domComputed = domComputed;
/**
 * Like domComputed(), but the callback gets an additional first argument, owner, which may be
 * used to take ownership of objects created by the callback. These will be disposed before each
 * new call to the callback, and when the containing DOM is disposed.
 *
 *    domComputedOwned(valueObs, (owner, value) => Editor.create(owner, value).renderSomething());
 */
function domComputedOwned(valueObs, contentFunc) {
    const holder = dispose_1.Holder.create(null);
    const [markerPre, markerPost, func] = domComputed(valueObs, (val) => contentFunc(dispose_1.MultiHolder.create(holder), val));
    domDispose_1.autoDisposeElem(markerPost, holder);
    return [markerPre, markerPost, func];
}
exports.domComputedOwned = domComputedOwned;
function identity(arg) { return arg; }
/**
 * Conditionally appends DOM to an element. The value may be an observable or function (from which
 * a computed is created), whose value -- if truthy -- will be passed to `contentFunc` which
 * should return DOM content. If the value is falsy, DOM content is removed.
 *
 * Note that if the observable changes between different truthy values, contentFunc gets called
 * for each value, and previous content gets destroyed. To consider all truthy values the same,
 * use an observable that returns a proper boolean, e.g.
 *
 *    dom.maybe(use => Boolean(use(fooObs)), () => dom(...));
 *
 * As with domComputed(), dom.maybe() may but should not be used when the argument is not an
 * observable or function. The following are equivalent:
 *
 *    dom(..., dom.maybe(myValue, () => dom(...)));
 *    dom(..., myValue ? dom(...) : null);
 *
 * The latter is preferred for being simpler.
 *
 * @param boolValueObs: Observable or function for a computed.
 * @param contentFunc: Called with the result of boolValueObs when it is truthy. Should return DOM.
 */
function maybe(boolValueObs, contentFunc) {
    return domComputed(boolValueObs, (value) => value ? contentFunc(value) : null);
}
exports.maybe = maybe;
/**
 * Like maybe(), but the callback gets an additional first argument, owner, which may be used to
 * take ownership of objects created by the callback. These will be disposed before each new call
 * to the callback, and when the condition becomes false or the containing DOM gets disposed.
 *
 *    maybeOwned(showEditor, (owner) => Editor.create(owner).renderSomething());
 */
function maybeOwned(boolValueObs, contentFunc) {
    return domComputedOwned(boolValueObs, (owner, value) => value ? contentFunc(owner, value) : null);
}
exports.maybeOwned = maybeOwned;
//# sourceMappingURL=domComputed.js.map