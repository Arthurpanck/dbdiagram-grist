/**
 * This module supports computed observables, organizing them into a priority queue, so that
 * computeds can be updated just once after multiple bundled changes.
 *
 * This module is for internal use only (hence the leading underscore in the name). The only
 * function useful outside is exposed via the `observable` module as `observable.bundleChanges()`.
 *
 * Changes may come together because multiple observables are changed synchronously, or because
 * multiple computeds depend on a single changed observable. In either case, if a computed depends
 * on multiple observables that are being changed, we want it to just get updated once when the
 * changes are complete.
 *
 * This is done by maintaining a _priority in each computed, where greater values get evaluated
 * later (computed with greater values depend on those with smaller values). When a computed needs
 * updating, it adds itself to the queue using enqueue() method. At the end of an observable.set()
 * call, or of bundleChanges() call, the queue gets processed in order of _priority.
 */
/**
 * DepItem is an item in a dependency relationship. It may depend on other DepItems. It is used
 * for subscriptions and computed observables.
 */
export declare class DepItem {
    static isPrioritySmaller(a: DepItem, b: DepItem): boolean;
    private _priority;
    private _enqueued;
    private _callback;
    private _context?;
    private _creation;
    /**
     * Callback should call depItem.useDep(dep) for each DepInput it depends on.
     */
    constructor(callback: () => void, optContext?: object);
    /**
     * Mark depItem as a dependency of this DepItem. The argument may be null to indicate a leaf (an
     * item such as a plain observable, which does not itself depend on anything else).
     */
    useDep(depItem: DepItem | null): void;
    /**
     * Recompute this DepItem, calling the callback given in the constructor.
     */
    recompute(): void;
    /**
     * Add this DepItem to the queue, to be recomputed when the time is right.
     */
    enqueue(): void;
}
/**
 * Exposed for unittests. Returns the internal priority value of an observable.
 */
export declare function _getPriority(obs: any): number;
/**
 * Update any computed observables that need updating. The update is deferred if we are currently
 * in the middle of a bundle. This is called automatically whenever you set an observable, and
 * there should be no need to ever call this by users of the library.
 */
export declare function compute(): void;
/**
 * Defer recomputations of all computed observables and subscriptions until func() returns. This
 * is useful to avoid unnecessary recomputation if you are making several changes to observables
 * together. This function is exposed as `observable.bundleChanges()`.
 *
 * Note that this intentionally does not wait for promises to be resolved, since that would block
 * all updates to all computeds while waiting.
 */
export declare function bundleChanges<T>(func: () => T): T;
