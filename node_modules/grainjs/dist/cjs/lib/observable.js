"use strict";
/**
 * observable.js implements an observable value, which lets other code subscribe to changes.
 *
 * E.g.
 *  let o = observable(17);
 *  o.get();          // 17
 *  o.addListener(foo);
 *  o.set("asdf");    // foo("asdf", 17) gets called.
 *  o.get();          // "asdf"
 *
 * To subscribe to changes, use obs.addListener(callback, context). The callback will get called
 * with (newValue, oldValue) as arguments.
 *
 * When you use observables within the body of a computed(), you can automatically create
 * subscriptions to them with the use(obs) function. E.g.
 *    let obs3 = computed(use => use(obs1) + use(obs2));
 * creates a computed observable `obs3` which is subscribed to changes to `obs1` and `obs2`.
 *
 * Note that unlike with knockout, use(obs) method requires an explicit `use` function, which is
 * always passed to a computed's read() callback for this purpose. This makes it explicit when a
 * dependency is created, and which observables the dependency connects.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.obsHolder = exports.observable = exports.Observable = exports.BaseObservable = exports.bundleChanges = void 0;
const _computed_queue_1 = require("./_computed_queue");
const dispose_1 = require("./dispose");
const emit_1 = require("./emit");
var _computed_queue_2 = require("./_computed_queue");
Object.defineProperty(exports, "bundleChanges", { enumerable: true, get: function () { return _computed_queue_2.bundleChanges; } });
class BaseObservable {
    /**
     * Internal constructor for an Observable. You should use observable() function instead.
     */
    constructor(value) {
        this._onChange = new emit_1.Emitter();
        this._value = value;
    }
    /**
     * Returns the value of the observable. It is fast and does not create a subscription.
     * (It is similar to knockout's peek()).
     * @returns {Object} The current value of the observable.
     */
    get() { return this._value; }
    /**
     * Sets the value of the observable. If the value differs from the previously set one, then
     * listeners to this observable will get called with (newValue, oldValue) as arguments.
     * @param {Object} value: The new value to set.
     */
    set(value) {
        if (value !== this._value) {
            this.setAndTrigger(value);
        }
    }
    /**
     * Sets the value of the observable AND calls listeners even if the value is unchanged.
     */
    setAndTrigger(value) {
        const prev = this._value;
        this._value = value;
        this._onChange.emit(value, prev);
        this._disposeOwned();
        _computed_queue_1.compute();
    }
    /**
     * Adds a callback to listen to changes in the observable.
     * @param {Function} callback: Function, called on changes with (newValue, oldValue) arguments.
     * @param {Object} optContext: Context for the function.
     * @returns {Listener} Listener object. Its dispose() method removes the callback.
     */
    addListener(callback, optContext) {
        return this._onChange.addListener(callback, optContext);
    }
    /**
     * Returns whether this observable has any listeners.
     */
    hasListeners() {
        return this._onChange.hasListeners();
    }
    /**
     * Sets a single callback to be called when a listener is added or removed. It overwrites any
     * previously-set such callback.
     * @param {Function} changeCB(hasListeners): Function to call after a listener is added or
     *    removed. It's called with a boolean indicating whether this observable has any listeners.
     *    Pass in `null` to unset the callback. Note that it can be called multiple times in a row
     *    with hasListeners `true`.
     */
    setListenerChangeCB(changeCB, optContext) {
        this._onChange.setChangeCB(changeCB, optContext);
    }
    /**
     * Used by subscriptions to keep track of dependencies. An observable that has dependnecies,
     * such as a computed observable, would override this method.
     */
    _getDepItem() {
        return null;
    }
    /**
     * Disposes the observable.
     */
    dispose() {
        this._disposeOwned();
        this._onChange.dispose();
        this._value = undefined;
    }
    /**
     * Returns whether this observable is disposed.
     */
    isDisposed() {
        return this._onChange.isDisposed();
    }
    _disposeOwned(arg) { }
    /**
     * Allow derived classes to emit change events with an additional third argument describing the
     * change. It always emits the event without checking for value equality.
     */
    _setWithArg(value, arg) {
        const prev = this._value;
        this._value = value;
        this._onChange.emit(value, prev, arg);
        this._disposeOwned(arg);
        _computed_queue_1.compute();
    }
}
exports.BaseObservable = BaseObservable;
class Observable extends BaseObservable {
    constructor() {
        super(...arguments);
        this._owned = undefined;
    }
    // See module-level holder() function below for documentation.
    static holder(value) {
        const obs = new Observable(value);
        obs._owned = value;
        return obs;
    }
    /**
     * Creates a new Observable with the given initial value, and owned by owner.
     */
    static create(owner, value) {
        return dispose_1.setDisposeOwner(owner, new Observable(value));
    }
    /**
     * The use an observable for a disposable object, use it a DisposableOwner:
     *
     *    D.create(obs, ...args)                      // Preferred
     *    obs.autoDispose(D.create(null, ...args))    // Equivalent
     *
     * Either of these usages will set the observable to the newly created value. The observable
     * will dispose the owned value when it's set to another value, or when it itself is disposed.
     */
    autoDispose(value) {
        this.setAndTrigger(value);
        this._owned = value;
        return value;
    }
    _disposeOwned() {
        if (this._owned) {
            this._owned.dispose();
            this._owned = undefined;
        }
    }
}
exports.Observable = Observable;
/**
 * Creates a new Observable with the initial value of optValue if given or undefined if omitted.
 * @param {Object} optValue: The initial value to set.
 * @returns {Observable} The newly created observable.
 */
function observable(value) {
    return new Observable(value);
}
exports.observable = observable;
/**
 * Creates a new Observable with an initial disposable value owned by this observable, e.g.
 *
 *    const obs = obsHolder<D>(D.create(null, ...args));
 *
 * This is needed because using simply observable<D>(value) would not cause the observable to take
 * ownership of value (i.e. to dispose it later). This function is a less hacky equivalent to:
 *
 *    const obs = observable<D>(null as any);
 *    D.create(obs, ...args);
 *
 * To allow nulls, use observable<D|null>(null); then the obsHolder() constructor is not needed.
 */
function obsHolder(value) {
    return Observable.holder(value);
}
exports.obsHolder = obsHolder;
//# sourceMappingURL=observable.js.map