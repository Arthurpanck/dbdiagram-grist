/**
 * binding.ts offers a convenient subscribe() function that creates a binding to an observable, a
 * a plain value, or a function from which it builds a computed.
 */
import { computed } from './computed';
import { autoDisposeElem } from './domDispose';
import { BaseObservable } from './observable';
import { subscribe } from './subscribe';
export function subscribeBindable(valueObs, callback) {
    // A plain function (to make a computed from), or a knockout observable.
    if (typeof valueObs === 'function') {
        // Knockout observable.
        const koValue = valueObs;
        if (typeof koValue.peek === 'function') {
            const sub = koValue.subscribe((val) => callback(val));
            callback(koValue.peek());
            return sub;
        }
        // Function from which to make a computed. Note that this is also reasonable:
        //    let sub = subscribe(use => callback(valueObs(use)));
        // The difference is that when valueObs() evaluates to unchanged value, callback would be
        // called in the version above, but not in the version below.
        const comp = computed(valueObs);
        comp.addListener((val) => callback(val));
        callback(comp.get());
        return comp; // Disposing this will dispose its one listener.
    }
    // An observable.
    if (valueObs instanceof BaseObservable) {
        // Use subscribe() rather than addListener(), so that bundling of changes (implicit and with
        // bundleChanges()) is respected. This matters when callback also uses observables.
        return subscribe(valueObs, (use, val) => callback(val));
    }
    callback(valueObs);
    return null;
}
/**
 * Subscribes a callback to valueObs (which may be a value, observable, or function) using
 * subscribe(), and disposes the subscription with the passed-in element.
 */
export function subscribeElem(elem, valueObs, callback) {
    autoDisposeElem(elem, subscribeBindable(valueObs, callback));
}
//# sourceMappingURL=binding.js.map