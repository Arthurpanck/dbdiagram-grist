import { subscribeElem } from './binding';
import { Holder, MultiHolder } from './dispose';
import { autoDisposeElem, domDispose } from './domDispose';
import { frag } from './domImpl';
// Use the browser globals in a way that allows replacing them with mocks in tests.
import { G } from './browserGlobals';
/**
 * Replaces the content between nodeBefore and nodeAfter, which should be two siblings within the
 * same parent node. New content may be anything allowed as an argument to dom(), including null
 * to insert nothing. Runs disposers, if any, on all removed content.
 */
export function replaceContent(nodeBefore, nodeAfter, content) {
    const elem = nodeBefore.parentNode;
    if (elem) {
        let next;
        for (let n = nodeBefore.nextSibling; n && n !== nodeAfter; n = next) {
            next = n.nextSibling;
            domDispose(n);
            elem.removeChild(n);
        }
        if (content) {
            elem.insertBefore(content instanceof G.Node ? content : frag(content), nodeAfter);
        }
    }
}
export function domComputed(valueObs, contentFunc = identity) {
    const markerPre = G.document.createComment('a');
    const markerPost = G.document.createComment('b');
    // Function is added after markerPre and markerPost, so that it runs once they have already been
    // attached to elem (the parent element).
    return [markerPre, markerPost, (elem) => {
            subscribeElem(markerPost, valueObs, (value) => replaceContent(markerPre, markerPost, contentFunc(value)));
        }];
}
/**
 * Like domComputed(), but the callback gets an additional first argument, owner, which may be
 * used to take ownership of objects created by the callback. These will be disposed before each
 * new call to the callback, and when the containing DOM is disposed.
 *
 *    domComputedOwned(valueObs, (owner, value) => Editor.create(owner, value).renderSomething());
 */
export function domComputedOwned(valueObs, contentFunc) {
    const holder = Holder.create(null);
    const [markerPre, markerPost, func] = domComputed(valueObs, (val) => contentFunc(MultiHolder.create(holder), val));
    autoDisposeElem(markerPost, holder);
    return [markerPre, markerPost, func];
}
function identity(arg) { return arg; }
/**
 * Conditionally appends DOM to an element. The value may be an observable or function (from which
 * a computed is created), whose value -- if truthy -- will be passed to `contentFunc` which
 * should return DOM content. If the value is falsy, DOM content is removed.
 *
 * Note that if the observable changes between different truthy values, contentFunc gets called
 * for each value, and previous content gets destroyed. To consider all truthy values the same,
 * use an observable that returns a proper boolean, e.g.
 *
 *    dom.maybe(use => Boolean(use(fooObs)), () => dom(...));
 *
 * As with domComputed(), dom.maybe() may but should not be used when the argument is not an
 * observable or function. The following are equivalent:
 *
 *    dom(..., dom.maybe(myValue, () => dom(...)));
 *    dom(..., myValue ? dom(...) : null);
 *
 * The latter is preferred for being simpler.
 *
 * @param boolValueObs: Observable or function for a computed.
 * @param contentFunc: Called with the result of boolValueObs when it is truthy. Should return DOM.
 */
export function maybe(boolValueObs, contentFunc) {
    return domComputed(boolValueObs, (value) => value ? contentFunc(value) : null);
}
/**
 * Like maybe(), but the callback gets an additional first argument, owner, which may be used to
 * take ownership of objects created by the callback. These will be disposed before each new call
 * to the callback, and when the condition becomes false or the containing DOM gets disposed.
 *
 *    maybeOwned(showEditor, (owner) => Editor.create(owner).renderSomething());
 */
export function maybeOwned(boolValueObs, contentFunc) {
    return domComputedOwned(boolValueObs, (owner, value) => value ? contentFunc(owner, value) : null);
}
//# sourceMappingURL=domComputed.js.map